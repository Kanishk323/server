<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Card Battle Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #a8dadc 0%, #457b9d 100%);
            text-align: center;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        #game-container {
            max-width: 900px;
            width: 100%;
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 25px;
            box-sizing: border-box;
            margin-top: 20px;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        h1 {
            color: #2b6cb0;
            font-size: 2.5em;
            margin-bottom: 25px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .player-area-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 2px solid #457b9d;
            border-radius: 12px;
            padding: 15px;
            background-color: #f0f8ff;
            margin-bottom: 20px;
        }

        .player-area-container.player1 {
            background-color: #e6f7ff;
        }

        .player-area-container.player2 {
            background-color: #fff0e6;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 12px;
            background-color: #e2e8f0;
            border-radius: 10px;
            font-weight: bold;
            color: #4a5568;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .ip-bar {
            width: 100px;
            height: 18px;
            background-color: #cbd5e0;
            border-radius: 9px;
            overflow: hidden;
            margin-left: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .ip-fill {
            height: 100%;
            background-color: #48bb78;
            width: 100%;
            transition: width 1.2s ease-out, background-color 1.2s ease-out;
            border-radius: 9px;
        }

        .ip-fill.low {
            background-color: #e53e3e;
        }

        .ip-fill.medium {
            background-color: #f6ad55;
        }

        .irrational-indicator,
        .imaginary-indicator {
            font-size: 1.1em;
            margin-left: 6px;
            color: #e53e3e;
            font-weight: bold;
        }

        #game-mode-select,
        #ai-difficulty-select,
        #branch-select {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        #game-mode-select label,
        #ai-difficulty-select label,
        #branch-select label {
            font-size: 1.1em;
            color: #444;
        }

        #game-mode-select select,
        #ai-difficulty-select select,
        #branch-select select {
            padding: 10px 15px;
            border: 2px solid #a0aec0;
            border-radius: 8px;
            font-size: 1em;
            background-color: #edf2f7;
            color: #2d3748;
            width: 80%;
            max-width: 250px;
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%234a5568' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 1.2em;
        }

        .game-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .game-button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            font-weight: bold;
        }

        .game-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .game-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .hand,
        .play-area {
            border: 2px dashed #a0aec0;
            padding: 15px;
            margin: 10px 0;
            min-height: 160px;
            background-color: #edf2f7;
            border-radius: 10px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .card {
            width: 90px;
            height: 130px;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, opacity 0.3s ease-out;
            position: relative;
            padding: 5px;
            box-sizing: border-box;
            opacity: 1;
        }

        .card.number {
            background-color: #3182ce;
        }

        .card.action {
            background-color: #dd6b20;
        }

        .card.theorem {
            background-color: #e53e3e;
        }

        .card:active {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .card-top {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding-top: 5px;
        }

        .card-icon {
            font-size: 2.2em;
            margin-bottom: 5px;
        }

        .card-name {
            font-size: 0.9em;
            text-align: center;
            line-height: 1.1;
        }

        .card-cost {
            font-size: 0.8em;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .card-summary-text {
            font-size: 0.65em;
            font-weight: normal;
            text-align: center;
            line-height: 1.1;
            padding: 0 2px;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: normal;
            word-break: break-word;
            color: rgba(255, 255, 255, 0.8);
        }

        .card-description-text {
            font-size: 0.7em;
            font-weight: normal;
            text-align: center;
            line-height: 1.2;
            padding: 0 2px;
            display: none;
            flex-grow: 1;
            align-items: center;
            justify-content: center;
        }

        .card.show-description .card-top,
        .card.show-description .card-summary-text {
            display: none;
        }

        .card.show-description .card-description-text {
            display: flex;
        }

        .deck-pile,
        .discard-pile {
            position: absolute;
            width: 90px;
            height: 130px;
            border-radius: 10px;
            background-color: #607d8b;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            transition: all 0.3s ease-out;
            border: 2px solid #455a64;
            z-index: 1;
        }

        .deck-pile {
            top: 20px;
            left: 20px;
            background-color: #607d8b;
        }

        .discard-pile {
            top: 20px;
            right: 20px;
            background-color: #b0bec5;
        }

        .deck-pile.empty,
        .discard-pile.empty {
            border: 2px dashed #ccc;
            background-color: #e0e0e0;
            color: #888;
        }

        .deck-pile span,
        .discard-pile span {
            position: absolute;
            bottom: 5px;
            font-size: 0.8em;
        }

        @keyframes drawCardAnimation {
            from {
                transform: translate(-150px, -150px) scale(0.5);
                opacity: 0;
            }

            to {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
        }

        .card.drawing {
            animation: drawCardAnimation 1.2s ease-out forwards;
        }

        @keyframes playCardAnimation {
            from {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            to {
                transform: translateY(-50px) scale(0.8);
                opacity: 0;
            }
        }

        .card.playing {
            animation: playCardAnimation 1.2s ease-out forwards;
        }

        @keyframes ipChangePulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(255, 255, 0, 0.7);
            }

            100% {
                transform: scale(1);
            }
        }

        .ip-value-display.pulse {
            animation: ipChangePulse 1.2s ease-out;
        }

        .floating-text {
            position: absolute;
            font-size: 1.8em;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transform: translateY(0);
            transition: transform 2.5s ease-out, opacity 2.5s ease-out;
            z-index: 100;
            text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.6);
        }

        .floating-text.damage {
            color: #e53e3e;
        }

        .floating-text.heal {
            color: #48bb78;
        }

        .floating-text.show {
            opacity: 1;
            transform: translateY(-70px);
        }

        #help-button {
            background-color: #007bff;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 10px;
        }

        #help-button:hover {
            background-color: #0056b3;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            text-align: left;
        }

        .modal-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.8em;
            cursor: pointer;
            color: #555;
        }

        .modal-close-button:hover {
            color: #333;
        }

        .modal-content h2 {
            font-size: 1.8em;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .modal-section h3 {
            font-size: 1.4em;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .modal-section p,
        .modal-section ul {
            font-size: 1em;
            line-height: 1.6;
            color: #666;
            margin-bottom: 10px;
        }

        .card-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .card-info {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .card-info strong {
            color: #3182ce;
        }

        .branch-info {
            background-color: #e2e8f0;
            border-left: 4px solid #4299e1;
            padding: 10px 15px;
            margin-bottom: 15px;
            border-radius: 6px;
        }

        .branch-info h4 {
            font-weight: bold;
            color: #2b6cb0;
            margin-bottom: 5px;
        }

        .branch-info p {
            font-size: 0.95em;
            color: #4a5568;
        }

        #chatbot-modal {
            z-index: 1001;
        }

        #chatbot-modal .modal-content {
            max-width: 500px;
            height: 600px;
            display: flex;
            flex-direction: column;
        }

        #chat-history-display {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #f7fafc;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-message {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 12px;
            word-wrap: break-word;
        }

        .chat-message.user {
            background-color: #3182ce;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 2px;
        }

        .chat-message.bot {
            background-color: #e2e8f0;
            color: #2d3748;
            align-self: flex-start;
            border-bottom-left-radius: 2px;
        }

        #chat-input-container {
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #a0aec0;
            border-radius: 8px;
            font-size: 1em;
        }

        #send-chat-btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #send-chat-btn:hover {
            background-color: #45a049;
        }

        #chat-loading-indicator {
            text-align: center;
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }

        #game-history-modal .modal-content {
            max-width: 600px;
            height: 700px;
        }

        #game-history-log {
            height: calc(100% - 60px);
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            background-color: #f7fafc;
            text-align: left;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .history-entry {
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px dotted #eee;
        }

        .history-entry:last-child {
            border-bottom: none;
        }

        .history-entry strong {
            color: #2b6cb0;
        }

        .history-entry.player1-action strong {
            color: #3182ce;
        }

        .history-entry.player2-action strong {
            color: #dd6b20;
        }

        .history-entry.game-event {
            font-style: italic;
            color: #666;
        }

        #player2-branch-selection-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .angle-slider-container {
            margin-top: 10px;
            padding: 10px;
            background-color: #e2e8f0;
            border-radius: 8px;
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.8em;
            }

            .status-bar {
                font-size: 0.9em;
                flex-direction: column;
                align-items: flex-start;
            }

            .ip-bar {
                width: 80px;
            }

            #game-mode-select select,
            #ai-difficulty-select select,
            #branch-select select,
            .game-button {
                width: 90%;
                padding: 10px 15px;
                font-size: 1em;
            }

            .card {
                width: 70px;
                height: 100px;
                font-size: 12px;
            }

            .card-icon {
                font-size: 1.8em;
            }

            .hand,
            .play-area {
                min-height: 120px;
                padding: 10px;
            }

            .modal-content {
                padding: 15px;
            }

            .modal-content h2 {
                font-size: 1.5em;
            }

            .modal-section h3 {
                font-size: 1.2em;
            }

            .game-buttons {
                flex-direction: column;
                gap: 10px;
            }

            .deck-pile,
            .discard-pile {
                width: 70px;
                height: 100px;
                font-size: 0.7em;
            }

            .deck-pile {
                top: 10px;
                left: 10px;
            }

            .discard-pile {
                top: 10px;
                right: 10px;
            }

            #chatbot-modal .modal-content {
                height: 90%;
            }

            #chat-input-container {
                flex-direction: column;
            }

            #send-chat-btn {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <!-- Multiplayer Lobby -->
    <div id="multiplayer-lobby" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
            <h2 class="text-2xl font-bold mb-6 text-center text-blue-600">Join Multiplayer Game</h2>

            <div class="mb-4">
                <label class="block text-sm font-medium mb-2">Your Name:</label>
                <input type="text" id="player-name-input" placeholder="Enter your name" 
                       class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>

            <div class="mb-4">
                <div class="text-sm text-gray-600 mb-2">Connection Status: 
                    <span id="connection-status" class="font-medium">Connecting...</span>
                </div>
            </div>

            <div class="flex gap-3">
                <button onclick="joinMultiplayerQueue()" 
                        class="flex-1 bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition-colors">
                    Find Opponent
                </button>
                <button onclick="document.getElementById('multiplayer-lobby').style.display='none'" 
                        class="flex-1 bg-gray-500 text-white p-3 rounded-lg hover:bg-gray-600 transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Game Messages -->
    <div id="game-messages" class="message"></div>

    <!-- Multiplayer Chat -->
    <div id="multiplayer-chat" class="fixed bottom-4 right-4 w-80 bg-white border border-gray-300 rounded-lg shadow-lg" style="display: none;">
        <div class="bg-blue-600 text-white p-3 rounded-t-lg">
            <h3 class="font-bold">Chat</h3>
        </div>
        <div id="multiplayer-chat-messages" class="h-40 overflow-y-auto p-3 bg-gray-50">
            <!-- Chat messages will appear here -->
        </div>
        <div class="p-3 border-t">
            <div class="flex gap-2">
                <input type="text" id="multiplayer-chat-input" placeholder="Type a message..." 
                       class="flex-1 p-2 border border-gray-300 rounded" 
                       onkeypress="if(event.key==='Enter') sendMultiplayerChat()">
                <button onclick="sendMultiplayerChat()" 
                        class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
                    Send
                </button>
            </div>
        </div>
    </div>

    <style>
        .message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .message.info {
            background-color: #3b82f6;
            color: white;
            opacity: 1;
        }

        .message.success {
            background-color: #10b981;
            color: white;
            opacity: 1;
        }

        .message.warning {
            background-color: #f59e0b;
            color: white;
            opacity: 1;
        }

        .message.error {
            background-color: #ef4444;
            color: white;
            opacity: 1;
        }

        .chat-message {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>

    <div id="game-container">
        <h1>Mathematical Card Battle</h1>
        <div id="game-mode-select">
            <label for="game-mode">Game Mode Chuno:</label>
            <select id="game-mode">
                <option value="vs_ai">AI ke saath khelo</option>
                <option value="vs_local_player">Local Player ke saath khelo</option>
            </select>
        </div>
        <div id="ai-difficulty-select" style="display: block;">
            <label for="ai-difficulty">AI ki Difficulty chuno:</label>
            <select id="ai-difficulty">
                <option value="easy">Easy</option>
                <option value="medium" selected>Medium</option>
                <option value="hard">Hard</option>
            </select>
        </div>
        <div id="branch-select">
            <label for="branch-player1">Apni Math Branch chuno (Player 1):</label>
            <select id="branch-player1" onchange="displayBranchEffects('player1')">
                <option value="Algebra">Algebra</option>
                <option value="Geometry">Geometry</option>
                <option value="Calculus">Calculus</option>
                <option value="Number Theory">Number Theory</option>
                <option value="Probability">Probability</option>
                <option value="Complex Analysis">Complex Analysis</option>
                <option value="Trigonometry">Trigonometry</option>
            </select>
            <div id="branch-effect-display-player1" class="branch-info w-full max-w-sm" style="display: none;"></div>

            <div id="player2-branch-selection-container">
                <label for="branch-player2">Player 2 ki Math Branch chuno:</label>
                <select id="branch-player2" onchange="displayBranchEffects('player2')">
                    <option value="Algebra">Algebra</option>
                    <option value="Geometry">Geometry</option>
                    <option value="Calculus">Calculus</option>
                    <option value="Number Theory">Number Theory</option>
                    <option value="Probability">Probability</option>
                    <option value="Complex Analysis">Complex Analysis</option>
                    <option value="Trigonometry">Trigonometry</option>
                </select>
                <div id="branch-effect-display-player2" class="branch-info w-full max-w-sm" style="display: none;"></div>
            </div>

            <button class="game-button" onclick="startGame()">Game Start karo</button>
        </div>

        <div id="game-ui" style="display: none;">
            <div class="deck-pile" id="deck-pile">
                Deck
                <span id="deck-count">0</span>
            </div>
            <div class="discard-pile" id="discard-pile">
                Discard
                <span id="discard-count">0</span>
            </div>

            <!-- Player 2 Area -->
            <div class="player-area-container player2">
                <div class="status-bar">
                    <span id="player2-name-display">Player 2 IP:</span>
                    <span id="player2-ip" class="ip-value-display">100.00</span>
                    <div class="ip-bar">
                        <div id="player2-ip-fill" class="ip-fill"></div>
                    </div>
                    <span id="player2-irrational-indicator" class="irrational-indicator" style="display: none;">($\sqrt{-1}$)</span>
                    <span id="player2-imaginary-indicator" class="imaginary-indicator" style="display: none;">(i)</span>
                    <span id="player2-tokens-display">Player 2 Tokens:</span>
                    <span id="player2-tokens">0</span>
                </div>
                <div id="player2-angle-slider-container" class="angle-slider-container">
                    <label for="player2-angle-slider">Angle: <span id="player2-angle-value">45</span>°</label>
                    <input type="range" min="0" max="90" value="45" class="slider w-full" id="player2-angle-slider">
                </div>
                <div class="hand" id="player2-hand" style="min-height: 50px;">Player 2's Hand</div>
                <div class="play-area" id="player2-play-area" style="min-height: 50px;">Player 2's Play Area</div>
            </div>

            <!-- Player 1 Area -->
            <div class="player-area-container player1">
                <div class="status-bar">
                    <span id="player1-name-display">Aapka IP:</span>
                    <span id="player1-ip" class="ip-value-display">100.00</span>
                    <div class="ip-bar">
                        <div id="player1-ip-fill" class="ip-fill"></div>
                    </div>
                    <span id="player1-irrational-indicator" class="irrational-indicator" style="display: none;">($\sqrt{-1}$)</span>
                    <span id="player1-imaginary-indicator" class="imaginary-indicator" style="display: none;">(i)</span>
                    <span id="player1-tokens-display">Tokens:</span>
                    <span id="player1-tokens">10</span>
                </div>
                 <div id="player1-angle-slider-container" class="angle-slider-container">
                    <label for="player1-angle-slider">Angle Control: <span id="player1-angle-value">45</span>°</label>
                    <input type="range" min="0" max="90" value="45" class="slider w-full" id="player1-angle-slider">
                </div>
                <div class="hand" id="player1-hand">Aapka Hand (Card description ke liye single tap, play karne ke liye double tap)</div>
                <div class="play-area" id="player1-play-area">Aapka Play Area (Played cards yahan dikhenge)</div>
            </div>
            <div class="text-lg font-semibold text-blue-700 my-4" id="current-phase-display"></div>

            <div class="game-buttons">
                <button id="end-play-phase-button" class="game-button" disabled>End Play Phase</button>
                <button id="end-turn-button" class="game-button" disabled>End Turn</button>
            </div>
            <div class="game-buttons">
                <button id="help-button" class="game-button" onclick="openHelpModal()">Help</button>
                <button id="history-button" class="game-button" onclick="openGameHistoryModal()">Game History</button>
                <button id="chatbot-button" class="game-button" onclick="openChatbotModal()">Chat with Math Bot</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button" onclick="closeHelpModal()">×</span>
            <h2>Game Rules & Card Powers</h2>
            <div class="modal-section">
                <h3>Game Objective</h3>
                <p>Apne opponent ke Intellectual Power (IP) ko 0 tak kam karo, usse pehle ki woh aapka kam kare. Cards play karke IP ko affect karte hain.</p>
            </div>
            <div class="modal-section">
                <h3>Kaise Khelen</h3>
                <ul>
                    <li><strong>Game Mode Select:</strong> Game start pe choose karo ki AI ke saath khelna hai ya local player ke saath. AI ke liye difficulty (Easy, Medium, Hard) bhi chuno.</li>
                    <li><strong>Branch Select:</strong> Har player apni favorite math branch chunta hai. Har branch ke apne pros aur cons hain.</li>
                    <li><strong>Phases:</strong> Har turn mein 4 phases hote hain:
                        <ul>
                            <li><strong>Draw Phase:</strong> Aap automatically cards draw karoge.</li>
                            <li><strong>Play Phase:</strong> Apne hand se cards play karo. Card ki description dekhne ke liye <strong>single tap</strong> karo. Card play karne ke liye <strong>double tap</strong> karo. Jab tak tokens hain, kitne bhi cards play kar sakte ho. Done hone pe "End Play Phase" click karo.</li>
                            <li><strong>Battle Phase:</strong> Aapke played cards ke effects resolve honge, aur phir opponent apna turn lega.</li>
                            <li><strong>Heal Phase:</strong> Koi bhi ongoing healing effects apply honge. "End Turn" click karke next round pe jao.</li>
                        </ul>
                    </li>
                    <li><strong>Tokens:</strong> Har card ki ek 'Cost' hoti hai. Card play karne ke liye utne tokens hone chahiye. Card play karne par ek sound bajega. Har turn mein tokens replenish hote hain.</li>
                    <li><strong>IP (Intellectual Power):</strong> Yeh aapki health hai. Agar 0 ya usse kam ho gayi, toh aap "Grace Period" mein chale jaoge.</li>
                    <li><strong>Grace Period:</strong> Jab aapka IP 0 ya usse kam hota hai, aapko 3 extra rounds (aapke 3 turn aur opponent ke 3 turn) milte hain apne aap ko heal karne ke liye. Agar grace period ke end tak aapka IP 0 ya usse kam rehta hai, toh aap haar jaoge.</li>
                    <li><strong>Deck & Discard:</strong> Cards deck se draw hote hain. Jab play hote hain, toh discard pile mein jaate hain. Jab deck khali ho jata hai, discard pile shuffle hoke naya deck ban jata hai.</li>
                </ul>
            </div>
            <div class="modal-section">
                <h3>Card Types</h3>
                <ul>
                    <li><strong>Number Cards:</strong> Direct numerical operations karte hain (e.g., add/subtract specific values).</li>
                    <li><strong>Action Cards:</strong> IP par transformations apply karte hain (e.g., derivative, limit, square root).</li>
                    <li><strong>Theorem Cards:</strong> Powerful, often game-changing effects hote hain (e.g., Pi/Naturalize combo, Euler's Identity).</li>
                </ul>
            </div>
            <div class="modal-section">
                <h3>Mathematical Branches</h3>
                <div id="modal-branch-effects-list"></div>
            </div>
            <div class="modal-section">
                <h3>Card Powers</h3>
                <div id="card-powers-list" class="card-list">
                    <!-- Card info will be dynamically loaded here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Game History Modal -->
    <div id="game-history-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button" onclick="closeGameHistoryModal()">×</span>
            <h2>Game History</h2>
            <div id="game-history-log">
                <!-- History entries will be added here -->
            </div>
        </div>
    </div>

    <!-- Chatbot Modal -->
    <div id="chatbot-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button" onclick="closeChatbotModal()">×</span>
            <h2>Math Bot Chat</h2>
            <div id="chat-history-display"></div>
            <div id="chat-input-container">
                <input type="text" id="chat-input" placeholder="Apna sawaal yahan type karo...">
                <button id="send-chat-btn" onclick="sendChatMessage()">Send</button>
            </div>
            <div id="chat-loading-indicator" style="display: none;">Typing...</div>
        </div>
    </div>

    <script>
        // Game State
        let gameMode = 'vs_ai'; // 'vs_ai' or 'vs_local_player'
        let aiDifficulty = 'medium'; // 'easy', 'medium', 'hard'
        let players = {
            player1: {
                ip: 100.0,
                tokens: 10,
                hand: [],
                blockDamage: 0,
                damageOverTime: {
                    active: false,
                    value: 0,
                    turns: 0
                },
                healOverTime: {
                    active: false,
                    value: 0,
                    turns: 0
                },
                doubleDamageNextTurn: false,
                reflectDamage: {
                    active: false,
                    value: 0,
                    turns: 0
                },
                isIPIrrational: false,
                isIPImaginary: false,
                selectedBranch: '',
                inGracePeriod: false,
                graceRoundsRemaining: -1,
                angle: 45
            },
            player2: { // This will be AI or Local Player 2
                ip: 100.0,
                tokens: 10,
                hand: [],
                blockDamage: 0,
                damageOverTime: {
                    active: false,
                    value: 0,
                    turns: 0
                },
                healOverTime: {
                    active: false,
                    value: 0,
                    turns: 0
                },
                doubleDamageNextTurn: false,
                reflectDamage: {
                    active: false,
                    value: 0,
                    turns: 0
                },
                isIPIrrational: false,
                isIPImaginary: false,
                selectedBranch: '',
                inGracePeriod: false,
                graceRoundsRemaining: -1,
                angle: 45
            }
        };
        let currentTurn = 0; // Tracks game turns
        let currentPlayer = 'player1'; // 'player1' or 'player2'
        let isGameOver = false;

        // Deck and Hand Management
        let deck = []; // Shared deck
        let discardPile = []; // Shared discard pile
        const MAX_HAND_SIZE = 10;
        const CARDS_TO_DRAW_PER_TURN = 5;
        const AI_MAX_HAND_SIZE = 10;
        const AI_CARDS_TO_DRAW_PER_TURN = 5;

        // Game Phases
        let currentPhase = 'draw'; // 'draw', 'play', 'battle', 'heal'
        let playedCardsThisTurn = []; // Cards played by current player in current Play Phase

        // Tone.js Player for background music and sound effects
        let playerSynth;
        let damageSound;
        let healSound;
        let cardDrawSound;
        let cardPlaySound;
        let winSound;
        let loseSound;

        // Chatbot state
        let chatHistory = [];
        const API_KEY = "YOUR_API_KEY";

        // Double tap detection variables
        let lastTapTime = 0;
        const DOUBLE_TAP_THRESHOLD = 300; // milliseconds

        // Game History Log
        let gameHistoryLog = [];

        // Custom alert/message box function
        function showMessage(message, duration = 8000) {
            const messageBox = document.createElement('div');
            messageBox.className = 'fixed inset-x-0 top-5 mx-auto flex items-center justify-center bg-blue-600 text-white p-4 rounded-lg shadow-xl z-50 transition-all duration-1000 transform opacity-0 scale-90';
            messageBox.style.maxWidth = '90%';
            messageBox.innerHTML = `<p class="text-xl font-semibold">${message}</p>`;
            document.body.appendChild(messageBox);

            setTimeout(() => {
                messageBox.style.opacity = '1';
                messageBox.style.transform = 'scale(1)';
            }, 10);

            setTimeout(() => {
                messageBox.style.opacity = '0';
                messageBox.style.transform = 'scale(0.9)';
                messageBox.addEventListener('transitionend', () => messageBox.remove());
            }, duration);
        }

        // Function to show floating text for IP changes
        function showFloatingText(value, type, targetElementId) {
            const targetElement = document.getElementById(targetElementId);
            if (!targetElement) return;
            const rect = targetElement.getBoundingClientRect();

            const floatingText = document.createElement('div');
            floatingText.textContent = (type === 'heal' ? '+' : '-') + Math.abs(value).toFixed(0);
            floatingText.className = `floating-text ${type}`;
            floatingText.style.left = `${rect.left + rect.width / 2}px`;
            floatingText.style.top = `${rect.top - 20}px`;
            document.body.appendChild(floatingText);

            setTimeout(() => {
                floatingText.classList.add('show');
            }, 10);

            floatingText.addEventListener('transitionend', () => {
                floatingText.remove();
            }, {
                once: true
            });
        }

        // Log game events to history
        function logGameEvent(message, type = 'game-event') {
            const entry = {
                turn: currentTurn,
                phase: currentPhase,
                message: message,
                type: type
            };
            gameHistoryLog.push(entry);
            console.log(`Turn ${currentTurn} - ${currentPhase}: ${message}`);

            if (document.getElementById('game-history-modal').classList.contains('show')) {
                updateGameHistoryDisplay();
            }
        }
        
        // New Function for Text-to-Speech
        function speakMessage(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'hi-IN';
                utterance.rate = 0.9;
                window.speechSynthesis.speak(utterance);
            } else {
                console.log("Speech synthesis not supported.");
            }
        }

        // Mathematical Branch Pros and Cons
        const branchEffects = {
            "Algebra": {
                pros: "Game start pe +5 Tokens milenge. Aapke Number cards +1 extra value denge.",
                cons: "Opponent ka base damage +2 zyada hoga.",
                apply: (player) => {
                    players[player].tokens += 5;
                }
            },
            "Geometry": {
                pros: "Game start pe +15 Player IP milega. Aapko pehle 3 turns ke liye +5 Block milega.",
                cons: "Aapke cards ki cost +1 token zyada hogi.",
                apply: (player) => {
                    players[player].ip += 15;
                    players[player].blockDamage += 5;
                }
            },
            "Calculus": {
                pros: "Aapke 'Damage over Time' aur 'Heal over Time' effects 1 turn zyada chalenge.",
                cons: "Aapke starting hand mein 1 card kam hoga.",
                apply: () => {},
                initial_hand_size_modifier: -1
            },
            "Number Theory": {
                pros: "Har turn +2 Tokens milne ka 20% chance hai.",
                cons: "Aapke Number cards ka 10% chance hai ki woh 0 damage karein.",
                apply: () => {}
            },
            "Probability": {
                pros: "Sab random effects (jaise random damage) ki range 50% badh jayegi.",
                cons: "Har turn 1 IP lose karne ka 15% chance hai.",
                apply: () => {}
            },
            "Complex Analysis": {
                pros: "Invert aur Swap effects se aapko 10 IP heal hoga.",
                cons: "Invert ya Swap effects wale Theorem cards ki cost +2 tokens zyada hogi.",
                apply: () => {}
            },
            "Trigonometry": {
                pros: "Aapke paas ek Angle Slider hoga. Angle ko strategically set karke apne cards ko boost karo.",
                cons: "Opponent ke IP ko multiply/divide karne wale cards ka asar 25% zyada hoga.",
                apply: () => {}
            }
        };

        // All Cards with Icons and descriptions
        const allCards = [
            // Number Cards
            { name: 'Plus 5', icon: '➕5️⃣', type: 'Number', cost: 1, effect: 'direct_value_change', value: 5, target: 'opponent', description: 'Opponent ke IP ko 5 se kam karta hai.', summary: 'IP -5' },
            { name: 'Heal 10', icon: '❤️‍🩹', type: 'Number', cost: 2, effect: 'direct_value_change', value: 10, target: 'self', description: 'Apne IP ko 10 se badhata hai.', summary: 'Apna IP +10' },
            { name: 'Add 10', icon: '➕🔟', type: 'Number', cost: 2, effect: 'direct_value_change', value: 10, target: 'opponent', description: 'Opponent ke IP ko 10 se kam karta hai.', summary: 'IP -10' },

            // Action Cards
            { name: 'Multiply by 2', icon: '✖️2️⃣', type: 'Action', cost: 3, effect: 'multiply_ip', value: 2, target: 'opponent', description: 'Opponent ke IP ko 2 se multiply karta hai.', summary: 'Opponent IP x2' },
            { name: 'Divide by 2', icon: '➗2️⃣', type: 'Action', cost: 3, effect: 'divide_ip', value: 2, target: 'opponent', description: 'Opponent ke IP ko 2 se divide karta hai.', summary: 'Opponent IP /2' },
            { name: 'Square IP', icon: '²️⃣', type: 'Action', cost: 4, effect: 'square_ip', target: 'self', description: 'Apne IP ka square karta hai (e.g., 10 -> 100). High-risk self-buff.', summary: 'Self IP²' },
            { name: 'Square Root IP', icon: '√', type: 'Action', cost: 3, effect: 'square_root_ip', target: 'opponent', description: 'Opponent ke IP ka square root leta hai (e.g., 100 -> 10).', summary: '√Opponent IP' },
            { name: 'Absolute Value', icon: '📏', type: 'Action', cost: 2, effect: 'absolute_value_ip', target: 'self', description: 'Apne negative ya imaginary IP ko positive real banata hai.', summary: '|Self IP|' },
            { name: 'Derivative ($d/dx$)', icon: '📈', type: 'Action', cost: 4, effect: 'derivative_effect', branch: 'Calculus', target: 'opponent', description: 'Opponent ke IP ko 0 kar deta hai (constant ka derivative 0 hota hai).', summary: 'Opponent IP = 0' },
            { name: 'Logarithm ($\\ln(x)$)', icon: '🌳', type: 'Action', cost: 3, effect: 'logarithm_effect', branch: 'Algebra', target: 'opponent', description: 'Opponent ke IP ka natural logarithm leta hai. Positive IP par hi kaam karta hai.', summary: 'ln(Opponent IP)' },
            { name: 'Draw Card', icon: '🃏', type: 'Action', cost: 1, effect: 'draw_card', value: 1, description: 'Ek extra card draw karta hai.', summary: '+1 Card' },
            { name: 'Random Damage (1-10)', icon: '❓', type: 'Action', cost: 2, effect: 'random_damage', value: { min: 1, max: 10 }, target: 'opponent', description: 'Opponent ko 1 se 10 tak random damage deta hai.', summary: 'IP -Rand(1-10)' },
            { name: 'Reciprocal', icon: '1️⃣/x', type: 'Action', cost: 3, effect: 'reciprocal_ip', target: 'opponent', description: 'Opponent ke IP ka reciprocal leta hai (1/IP). 100 ko 0.01 bana deta hai!', summary: '1/Opponent IP' },
            { name: 'Power of 0', icon: '⁰', type: 'Action', cost: 1, effect: 'power_of_zero', target: 'opponent', description: 'Opponent ke IP ko 1 kar deta hai (agar IP 0 na ho).', summary: 'Opponent IP = 1' },
            { name: 'Copy IP', icon: '📋', type: 'Action', cost: 3, effect: 'copy_ip', target: 'self', description: 'Apne IP ko Opponent ke current IP ke barabar karta hai.', summary: 'Self IP = Opponent IP' },
            { name: 'Token Chori', icon: '💸', type: 'Action', cost: 2, effect: 'steal_token', value: 2, target: 'opponent', description: 'Opponent se 2 tokens chori karta hai.', summary: 'Tokens -2 (Opponent)' },
            { name: 'Prime Decomposition', icon: '🧩', type: 'Action', cost: 3, effect: 'prime_factor_damage', branch: 'Number Theory', target: 'opponent', description: 'Opponent ke IP ke sabse bade prime factor ke barabar damage deta hai (IP ko integer banaya jayega).', summary: 'Dmg = LPF(IP)' },
            { name: 'Negative Imaginary Square', icon: '(i)²', type: 'Action', cost: 3, effect: 'negative_imaginary_square', target: 'opponent', branch: 'Complex Analysis', description: "Agar opponent ka IP imaginary hai, to uska square karke usse ek negative real number bana deta hai (i*x -> -x²).", summary: 'If i*IP, IP -> -IP²' },

            // Theorem Cards
            { name: 'Invert IP Sign', icon: '➖➕', type: 'Theorem', cost: 6, effect: 'invert_sign_ip', target: 'opponent', description: 'Opponent ke IP ka sign change karta hai (e.g., 80 -> -80).', summary: 'Opponent IP -> -IP' },
            { name: 'Factorial (!)', icon: '🔢!', type: 'Theorem', cost: 5, effect: 'factorial_ip', branch: 'Number Theory', target: 'self', description: 'Apne IP ko uske factorial se replace karta hai. Sirf 0-12 ke beech ke integers par kaam karta hai. High-risk self-buff.', summary: 'Self IP -> IP!' },
            { name: 'Gamma Function ($\\Gamma$)', icon: 'Γ', type: 'Theorem', cost: 6, effect: 'gamma_function_ip', branch: 'Calculus', target: 'self', description: 'Apne IP par Gamma function (factorial ka generalization) apply karta hai. High-risk self-buff.', summary: 'Self IP -> Γ(IP)' },
            { name: 'Pi ($\\pi$)', icon: '🥧', type: 'Theorem', cost: 2, effect: 'divide_by_pi', branch: 'Geometry', target: 'opponent', description: 'Opponent ke IP ko $\\pi$ se divide karta hai, making it irrational.', summary: 'IP / $\\pi$ (Irrational)' },
            { name: 'Swap IPs', icon: '🔄', type: 'Theorem', cost: 4, effect: 'swap_ips', branch: 'Complex Analysis', description: 'Apne IP ko opponent ke IP se swap karta hai.', summary: 'Swap IPs' },
            { name: 'Triangle Inequality', icon: '🔺', type: 'Theorem', cost: 5, effect: 'block_damage', branch: 'Geometry', value: 10, target: 'self', description: 'Apne next 10 damage ko block karta hai.', summary: 'Block 10 Damage' },
            { name: "Euler's Identity", icon: '✨', type: 'Theorem', cost: 10, effect: 'one_hit_ko_chance', branch: 'Complex Analysis', target: 'opponent', description: 'Opponent IP ko 1 tak kam karne ka 50% chance.', summary: '50% Chance IP=1' },
            { name: 'Fibonacci Sequence', icon: '🐚', type: 'Theorem', cost: 3, effect: 'heal_over_time', value: 3, turns: 2, branch: 'Number Theory', target: 'self', description: 'Aapko 2 turns ke liye 3 IP heal karta hai.', summary: 'Heal 3/Turn (2T)' },
            { name: 'Matrix Inversion', icon: '🔲', type: 'Theorem', cost: 5, effect: 'double_damage_next_turn', branch: 'Algebra', target: 'self', description: 'Aapka next damage card double damage karega.', summary: 'Next Damage x2' },
            { name: 'Natural Number Set', icon: 'ℕ', type: 'Theorem', cost: 5, effect: 'natural_number_set_effect', branch: 'Number Theory', target: 'opponent', description: 'Agar Opponent ka IP irrational hai, toh usko 0 par set karta hai.', summary: 'Irrational IP = 0' },
            { name: 'Riemann Hypothesis', icon: '❓', type: 'Theorem', cost: 12, effect: 'ultimate_damage', value: 30, branch: 'Number Theory', target: 'opponent', description: 'Massive 30 damage deta hai, but cost bahut zyada hai.', summary: 'IP -30 (High Cost)' },
            { name: 'Shunya Hastak', icon: '✋', type: 'Theorem', cost: 4, effect: 'discard_hand', target: 'opponent', description: 'Opponent ko apna poora hand discard karne par majboor karta hai.', summary: 'Opponent Discard Hand' },
            { name: 'Pratibimbit Kshati', icon: '🪞', type: 'Theorem', cost: 6, effect: 'reflect_damage', value: 0.5, turns: 1, target: 'self', description: 'Next turn mein opponent se aane wale damage ka 50% wapas opponent ko deta hai.', summary: 'Reflect 50% Damage (1T)' },
            { name: 'Complex Rotation (×i)', icon: '🔄i', type: 'Theorem', cost: 5, effect: 'rotate_to_imaginary', branch: 'Complex Analysis', target: 'opponent', description: 'Opponent ke IP ko imaginary banata hai. Isse normal damage se bachaya ja sakta hai, lekin Square IP jaise card se khatra hai.', summary: 'IP -> i * IP' },
            { name: 'Real Projection (Re(z))', icon: 'Re(z)', type: 'Theorem', cost: 3, effect: 'real_projection', branch: 'Complex Analysis', target: 'opponent', description: 'Agar opponent ka IP imaginary hai, toh usse 0 kar deta hai.', summary: 'If i*IP, IP=0' },
            { name: 'Imaginary Annihilation (×i)', icon: '💥i', type: 'Theorem', cost: 4, effect: 'imaginary_annihilation', target: 'opponent', branch: 'Complex Analysis', description: "Opponent ke imaginary IP ko 'i' se multiply karta hai, jisse woh ek negative real number ban jaata hai (i*x -> -x).", summary: 'If i*IP, IP -> -IP' },
            { name: "Euler's Transformation", icon: 'e^ix', type: 'Theorem', cost: 5, effect: 'eulers_transformation', target: 'opponent', branch: 'Complex Analysis', description: "Opponent ke IP ko e^(i*IP) ke real part (cos(IP)) mein badal deta hai. Unka IP -1 aur 1 ke beech mein aa jaayega.", summary: 'IP -> cos(IP)' },
            { name: "De Moivre's Gambit", icon: '(cosθ+isinθ)ⁿ', type: 'Theorem', cost: 4, effect: 'de_moivres_gambit', target: 'opponent', branch: 'Complex Analysis', description: "Agar opponent ka IP imaginary hai, to usse ek random power (2 se 5) tak raise karta hai. Result unpredictable ho sakta hai!", summary: 'If i*IP, IP -> (i*IP)^n' },

            // Trigonometry Cards
            { name: 'Sine Wave', icon: '🌊', type: 'Action', cost: 3, effect: 'sine_wave_damage', value: 15, target: 'opponent', branch: 'Trigonometry', description: 'Opponent ko (15 * sin(angle)) damage deta hai. 90° par sabse zyada effective.', summary: 'Dmg = 15*sin(θ)' },
            { name: 'Cosine Shield', icon: '🛡️', type: 'Action', cost: 3, effect: 'cosine_shield', value: 20, target: 'self', branch: 'Trigonometry', description: 'Agle attack se (20 * cos(angle)) damage block karta hai. 0° par sabse zyada effective.', summary: 'Block = 20*cos(θ)' },
            { name: 'Law of Cosines', icon: '📐', type: 'Theorem', cost: 5, effect: 'deal_damage_based_on_ip_diff', target: 'opponent', branch: 'Trigonometry', description: 'Aapke aur opponent ke IP ke difference ke (50% + 20% * cos(angle)) ke barabar damage deta hai.', summary: 'Dmg by IP diff & angle' },
            { name: 'Secant Strike', icon: '⚡', type: 'Theorem', cost: 6, effect: 'secant_strike', value: 10, target: 'opponent', branch: 'Trigonometry', description: 'Opponent ko (10 * sec(angle)) damage deta hai. High-risk, high-reward! 90° ke paas bahut powerful.', summary: 'Dmg = 10*sec(θ)' }
        ];

        // --- Game Setup and Flow ---
        function initializeDeck() {
            const p1Branch = players.player1.selectedBranch;
            const p2Branch = players.player2.selectedBranch;
            const totalDeckSize = 50;

            const p1BranchCards = allCards.filter(c => c.branch === p1Branch);
            const p2BranchCards = allCards.filter(c => c.branch === p2Branch && c.branch !== p1Branch);
            const generalCards = allCards.filter(c => !c.branch);

            let weightedDeck = [];

            const targetBranchCards = Math.floor(totalDeckSize * 0.5);
            
            if (p1BranchCards.length > 0) {
                 for (let i = 0; i < Math.ceil(targetBranchCards / (p1BranchCards.length + p2BranchCards.length || 1)); i++) {
                    weightedDeck.push(...p1BranchCards);
                }
            }
            if (p2BranchCards.length > 0) {
                 for (let i = 0; i < Math.ceil(targetBranchCards / (p1BranchCards.length + p2BranchCards.length || 1)); i++) {
                    weightedDeck.push(...p2BranchCards);
                }
            }

            weightedDeck.push(...generalCards);
            
            deck = weightedDeck.sort(() => 0.5 - Math.random()).slice(0, totalDeckSize);
            
            discardPile = [];
            updateDeckDiscardCounts();
            logGameEvent(`Deck of ${deck.length} cards created with emphasis on ${p1Branch} and ${p2Branch}.`, 'game-event');
        }

        function initializeSounds() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            damageSound = new Tone.MembraneSynth().toDestination();
            healSound = new Tone.Synth().toDestination();
            cardDrawSound = new Tone.PluckSynth().toDestination();
            cardPlaySound = new Tone.MetalSynth().toDestination();
            winSound = new Tone.PolySynth(Tone.Synth).toDestination();
            loseSound = new Tone.NoiseSynth().toDestination();
        }

        async function playSound(type) {
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }

            if (type === 'damage') {
                damageSound.triggerAttackRelease("C2", "8n");
            } else if (type === 'heal') {
                healSound.triggerAttackRelease("G4", "8n");
            } else if (type === 'cardDraw') {
                cardDrawSound.triggerAttackRelease("C5", "16n");
            } else if (type === 'cardPlay') {
                cardPlaySound.triggerAttackRelease("8n");
            } else if (type === 'win') {
                winSound.triggerAttackRelease(["C4", "E4", "G4", "C5"], "1n");
            } else if (type === 'lose') {
                loseSound.triggerAttackRelease("4n");
            }
        }

        async function drawCard(playerType, num) {
            return new Promise(resolve => {
                let drawnCount = 0;
                const drawInterval = setInterval(() => {
                    let handRef = players[playerType].hand;
                    let maxHandSize = (playerType === 'player1' ? MAX_HAND_SIZE : AI_MAX_HAND_SIZE); 

                    if (drawnCount >= num || handRef.length >= maxHandSize) {
                        clearInterval(drawInterval);
                        renderHand(playerType);
                        resolve();
                        return;
                    }

                    if (deck.length === 0) {
                        if (discardPile.length === 0) {
                            showMessage('Aur cards draw karne ke liye nahi hain!', 8000);
                            logGameEvent('Deck aur Discard Pile dono khali hain. No more cards to draw.', 'game-event');
                            clearInterval(drawInterval);
                            renderHand(playerType);
                            resolve();
                            return;
                        }
                        showMessage('Discard pile ko deck mein shuffle kiya ja raha hai!', 8000);
                        logGameEvent('Discard Pile ko shuffle karke naya Deck banaya gaya.', 'game-event');
                        deck = [...discardPile].sort(() => 0.5 - Math.random());
                        discardPile = [];
                        updateDeckDiscardCounts();
                    }

                    if (deck.length > 0) {
                        const cardToDraw = deck.shift();
                        handRef.push(cardToDraw);
                        logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ne "${cardToDraw.name}" card draw kiya.`, `${playerType}-action`);

                        if (playerType === 'player1' || (playerType === 'player2' && gameMode === 'vs_local_player')) {
                            renderHand(playerType, true);
                            playSound('cardDraw');
                        }
                        updateDeckDiscardCounts();
                        drawnCount++;
                    }
                }, 1000);
            });
        }

        function startGame() {
            gameMode = document.getElementById('game-mode').value;
            aiDifficulty = document.getElementById('ai-difficulty').value;
            isGameOver = false;

            if (playerSynth) {
                Tone.Transport.stop();
                Tone.Transport.cancel();
                playerSynth.dispose();
                playerSynth = null;
            }
            initializeSounds();

            Tone.start();
            playerSynth = new Tone.Synth().toDestination();
            const notes = ["C4", "E4", "G4", "C5"];
            let index = 0;
            Tone.Transport.scheduleRepeat(time => {
                playerSynth.triggerAttackRelease(notes[index % notes.length], "8n", time);
                index++;
            }, "4n");
            Tone.Transport.start();

            document.getElementById('game-mode-select').style.display = 'none';
            document.getElementById('ai-difficulty-select').style.display = 'none';
            document.getElementById('branch-select').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';

            const createPlayerState = () => ({
                ip: 100.0,
                tokens: 10,
                hand: [],
                blockDamage: 0,
                damageOverTime: { active: false, value: 0, turns: 0 },
                healOverTime: { active: false, value: 0, turns: 0 },
                doubleDamageNextTurn: false,
                reflectDamage: { active: false, value: 0, turns: 0 },
                isIPIrrational: false,
                isIPImaginary: false,
                selectedBranch: '',
                inGracePeriod: false,
                graceRoundsRemaining: -1,
                angle: 45
            });
            players.player1 = createPlayerState();
            players.player2 = createPlayerState();
            currentTurn = 0;
            currentPlayer = 'player1';
            playedCardsThisTurn = [];
            gameHistoryLog = [];

            players.player1.selectedBranch = document.getElementById('branch-player1').value;
            if (gameMode === 'vs_ai') {
                const allBranches = Object.keys(branchEffects);
                const availableBranches = allBranches.filter(b => b !== players.player1.selectedBranch);
                players.player2.selectedBranch = availableBranches[Math.floor(Math.random() * availableBranches.length)];
            } else {
                players.player2.selectedBranch = document.getElementById('branch-player2').value;
            }
            
            initializeDeck();

            document.getElementById('player1-name-display').textContent = 'Aapka IP:';
            document.getElementById('player1-tokens-display').textContent = 'Tokens:';
            if (gameMode === 'vs_ai') {
                document.getElementById('player2-name-display').textContent = `AI IP (${aiDifficulty}):`;
                document.getElementById('player2-tokens-display').textContent = 'AI Tokens:';
            } else {
                document.getElementById('player2-name-display').textContent = 'Player 2 IP:';
                document.getElementById('player2-tokens-display').textContent = 'Player 2 Tokens:';
            }

            branchEffects[players.player1.selectedBranch].apply('player1');
            logGameEvent(`Player 1 ne ${players.player1.selectedBranch} branch chuni. Iske starting effects apply hue.`, 'game-event');
            branchEffects[players.player2.selectedBranch].apply('player2');
            logGameEvent(`${gameMode === 'vs_ai' ? 'AI' : 'Player 2'} ne ${players.player2.selectedBranch} branch chuni. Iske starting effects apply hue.`, 'game-event');

            let player1InitialHandSize = 5;
            if (branchEffects[players.player1.selectedBranch].initial_hand_size_modifier) {
                player1InitialHandSize += branchEffects[players.player1.selectedBranch].initial_hand_size_modifier;
            }
            player1InitialHandSize = Math.max(1, player1InitialHandSize);

            let player2InitialHandSize = 5;
            if (branchEffects[players.player2.selectedBranch].initial_hand_size_modifier) {
                player2InitialHandSize += branchEffects[players.player2.selectedBranch].initial_hand_size_modifier;
            }
            player2InitialHandSize = Math.max(1, player2InitialHandSize);

            for (let i = 0; i < player1InitialHandSize; i++) {
                if (deck.length > 0) players.player1.hand.push(deck.shift());
            }
            for (let i = 0; i < player2InitialHandSize; i++) {
                if (deck.length > 0) players.player2.hand.push(deck.shift());
            }

            renderHand('player1');
            renderHand('player2');
            updateStatus();
            startTurnCycle();
        }

        async function startTurnCycle() {
            if (isGameOver) return;
            currentTurn++;
            logGameEvent(`--- Turn ${currentTurn} Start ---`, 'game-event');

            currentPlayer = 'player1';
            logGameEvent('Aapki baari hai!', 'game-event');
            await handleFullPlayerTurn('player1');
            if (isGameOver) return;

            currentPlayer = 'player2';
            if (gameMode === 'vs_ai') {
                logGameEvent('AI ki baari hai!', 'game-event');
                await simulateAITurn();
            } else {
                logGameEvent('Player 2 ki baari hai!', 'game-event');
                await handleFullPlayerTurn('player2');
            }
            if (isGameOver) return;

            setTimeout(startTurnCycle, 4000);
        }

        async function handleFullPlayerTurn(playerType) {
            if (players[playerType].inGracePeriod) {
                players[playerType].graceRoundsRemaining--;
                showMessage(`${playerType === 'player1' ? 'Aapke' : (gameMode === 'vs_ai' ? 'AI ke' : 'Player 2 ke')} grace period ke ${players[playerType].graceRoundsRemaining} turn bache hain!`, 4000);
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : 'Player 2'} is in grace period. ${players[playerType].graceRoundsRemaining} turns left.`, 'game-event');
            }
            if (checkGameEnd()) return;

            currentPhase = 'draw';
            updatePhaseDisplay();
            playedCardsThisTurn = [];

            applyPerTurnEffects(playerType);
            await drawCard(playerType, CARDS_TO_DRAW_PER_TURN);
            await new Promise(resolve => setTimeout(resolve, 2000));

            currentPhase = 'play';
            updatePhaseDisplay();
            if (playerType === 'player1' || (playerType === 'player2' && gameMode === 'vs_local_player')) {
                document.getElementById('end-play-phase-button').disabled = false;
                document.getElementById('end-turn-button').disabled = true;
                document.getElementById('end-play-phase-button').textContent = `${playerType === 'player1' ? 'Aapka' : 'Player 2 ka'} Play Phase End karo`;
                showMessage(`${playerType === 'player1' ? 'Aapka' : 'Player 2 ka'} Play Phase: Cards play karne ke liye double tap karo.`, 8000);

                renderHand('player1');
                renderHand('player2');

                document.getElementById('player1-hand').style.pointerEvents = (playerType === 'player1' ? 'auto' : 'none');
                document.getElementById('player2-hand').style.pointerEvents = (playerType === 'player2' ? 'auto' : 'none');
                document.getElementById('player1-hand').style.opacity = (playerType === 'player1' ? '1' : '0.5');
                document.getElementById('player2-hand').style.opacity = (playerType === 'player2' ? '1' : '0.5');
                
                document.getElementById('player1-angle-slider').disabled = (playerType !== 'player1');
                document.getElementById('player2-angle-slider').disabled = (playerType !== 'player2');

                await new Promise(resolve => {
                    const endPlayButton = document.getElementById('end-play-phase-button');
                    endPlayButton.onclick = async () => {
                        endPlayButton.disabled = true;
                        resolve();
                    };
                });
            }

            currentPhase = 'battle';
            updatePhaseDisplay();
            showMessage(`${playerType === 'player1' ? 'Aapke' : (gameMode === 'vs_ai' ? 'AI ke' : 'Player 2 ke')} cards ke effects resolve ho rahe hain!`, 8000);
            await resolveBattlePhase(playerType);
            if (checkGameEnd()) return;

            await applyGeneralAttack(playerType);
            if (checkGameEnd()) return;
            await new Promise(resolve => setTimeout(resolve, 3000));

            currentPhase = 'heal';
            updatePhaseDisplay();
            showMessage(`${playerType === 'player1' ? 'Aapki' : (gameMode === 'vs_ai' ? 'AI ki' : 'Player 2 ki')} Heal Phase: Ongoing effects apply ho rahe hain.`, 8000);
            await applyHealDamageOverTime(playerType);
            if (checkGameEnd()) return;
            await new Promise(resolve => setTimeout(resolve, 3000));

            updateStatus();
            if (checkGameEnd()) return;

            if (playerType === 'player1' || (playerType === 'player2' && gameMode === 'vs_local_player')) {
                document.getElementById('end-turn-button').disabled = false;
                document.getElementById('end-turn-button').textContent = `${playerType === 'player1' ? 'Aapka' : 'Player 2 ka'} Turn End karo`;
                showMessage('Heal Phase complete. "End Turn" click karke next player ko turn do.', 8000);

                await new Promise(resolve => {
                    const endTurnButton = document.getElementById('end-turn-button');
                    endTurnButton.onclick = async () => {
                        endTurnButton.disabled = true;
                        resolve();
                    };
                });
            }
            
            if (gameMode === 'vs_local_player') {
                const nextPlayer = playerType === 'player1' ? 'Player 2' : 'Player 1';
                const message = `${playerType === 'player1' ? 'Player 1' : 'Player 2'} ki turn khatam ho chuki hai. Ab ${nextPlayer} ki baari hai. Pass the device.`;
                showMessage(message, 6000);
                speakMessage(message);
            }

            logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ka turn khatam hua.`, 'game-event');
        }

        function applyPerTurnEffects(playerType) {
            players[playerType].tokens = Math.min(10, players[playerType].tokens + 3);
            logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ke tokens replenish hue.`, 'game-event');

            const activeBranch = players[playerType].selectedBranch;
            if (activeBranch === 'Number Theory' && Math.random() < 0.2) {
                players[playerType].tokens = Math.min(10, players[playerType].tokens + 2);
                showMessage(`${playerType === 'player1' ? 'Aapki' : (gameMode === 'vs_ai' ? 'AI ki' : 'Player 2 ki')} Number Theory bonus! +2 extra tokens mile.`, 4000);
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ko Number Theory bonus se +2 extra tokens mile.`, 'game-event');
            }
            if (activeBranch === 'Probability' && Math.random() < 0.15) {
                players[playerType].ip -= 1;
                showFloatingText(1, 'damage', `${playerType}-ip`);
                playSound('damage');
                showMessage(`${playerType === 'player1' ? 'Aapki' : (gameMode === 'vs_ai' ? 'AI ki' : 'Player 2 ki')} Probability branch con: Ek unstable calculation ki wajah se 1 IP lose kiya!`, 4500);
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ne Probability con se 1 IP lose kiya.`, 'game-event');
            }
        }

        async function resolveBattlePhase(playerType) {
            for (const card of playedCardsThisTurn) {
                await applyCardEffect(card, playerType);
                if (checkGameEnd()) return;
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            playedCardsThisTurn = [];
        }

        async function applyGeneralAttack(playerType) {
            let baseDamage = 5.0;
            const opponentPlayerType = (playerType === 'player1' ? 'player2' : 'player1');
            const opponentPlayerData = players[opponentPlayerType];

            if (players[opponentPlayerType].selectedBranch === 'Algebra') {
                baseDamage += 2;
            }

            if (opponentPlayerData.isIPImaginary) {
                showMessage(`General attack ka imaginary IP par koi asar nahi hua!`, 4000);
                logGameEvent(`General attack ka imaginary IP par koi asar nahi hua.`, 'game-event');
                return;
            }

            let finalDamage = baseDamage;

            if (opponentPlayerData.reflectDamage.active) {
                const reflectedAmount = finalDamage * opponentPlayerData.reflectDamage.value;
                players[playerType].ip -= reflectedAmount;
                showFloatingText(reflectedAmount, 'damage', `${playerType}-ip`);
                playSound('damage');
                showMessage(`${opponentPlayerType === 'player1' ? 'Aapke' : (gameMode === 'vs_ai' ? 'AI ke' : 'Player 2 ke')} Reflect Damage ne ${playerType === 'player1' ? 'aapko' : (gameMode === 'vs_ai' ? 'AI ko' : 'Player 2 ko')} ${reflectedAmount.toFixed(2)} damage diya!`, 4000);
                logGameEvent(`${opponentPlayerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} Reflect Damage ne ${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ko ${reflectedAmount.toFixed(2)} damage diya.`, 'game-event');
                finalDamage -= reflectedAmount;
                opponentPlayerData.reflectDamage.turns--;
                if (opponentPlayerData.reflectDamage.turns <= 0) {
                    opponentPlayerData.reflectDamage.active = false;
                    logGameEvent(`${opponentPlayerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ka Reflect Damage effect end hua.`, 'game-event');
                }
            }

            if (opponentPlayerData.blockDamage > 0) {
                const actualDamageToTarget = Math.max(0, finalDamage - opponentPlayerData.blockDamage);
                opponentPlayerData.blockDamage -= finalDamage;
                opponentPlayerData.ip -= actualDamageToTarget;
                showFloatingText(actualDamageToTarget, 'damage', `${opponentPlayerType}-ip`);
                playSound('damage');
                showMessage(`${playerType === 'player1' ? 'Aapne' : (gameMode === 'vs_ai' ? 'AI ne' : 'Player 2 ne')} ${baseDamage.toFixed(2)} damage kiya. ${baseDamage - actualDamageToTarget.toFixed(2)} damage block hua!`, 4500);
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ne ${baseDamage.toFixed(2)} damage diya. ${opponentPlayerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ne ${baseDamage - actualDamageToTarget.toFixed(2)} damage block kiya.`, 'game-event');
                if (opponentPlayerData.blockDamage <= 0) {
                    opponentPlayerData.blockDamage = 0;
                    logGameEvent(`${opponentPlayerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ka Block effect end hua.`, 'game-event');
                }
            } else {
                opponentPlayerData.ip -= finalDamage;
                showFloatingText(finalDamage, 'damage', `${opponentPlayerType}-ip`);
                playSound('damage');
                showMessage(`${playerType === 'player1' ? 'Aapne' : (gameMode === 'vs_ai' ? 'AI ne' : 'Player 2 ne')} ${finalDamage.toFixed(2)} damage diya!`, 4000);
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ne ${finalDamage.toFixed(2)} damage diya.`, 'game-event');
            }
        }

        async function applyHealDamageOverTime(playerType) {
            const player = players[playerType];

            if (player.healOverTime.active) {
                const healAmount = player.healOverTime.value;
                player.ip += healAmount;
                player.healOverTime.turns--;
                showFloatingText(healAmount, 'heal', `${playerType}-ip`);
                playSound('heal');
                showMessage(`${playerType === 'player1' ? 'Aapko' : (gameMode === 'vs_ai' ? 'AI ko' : 'Player 2 ko')} ongoing effect se ${healAmount} IP heal hua.`, 4000);
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ko ongoing effect se ${healAmount} IP heal hua.`, 'game-event');

                if (player.healOverTime.turns <= 0) {
                    player.healOverTime.active = false;
                    logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ka Heal over time effect end hua.`, 'game-event');
                }
            }

            if (player.damageOverTime.active) {
                const damageAmount = player.damageOverTime.value;
                if (player.isIPImaginary) {
                    showMessage(`Damage over time ka imaginary IP par koi asar nahi hua!`, 4000);
                    logGameEvent(`Damage over time ka imaginary IP par koi asar nahi hua.`, 'game-event');
                } else {
                    player.ip -= damageAmount;
                    showFloatingText(damageAmount, 'damage', `${playerType}-ip`);
                    playSound('damage');
                    showMessage(`${playerType === 'player1' ? 'Aapko' : (gameMode === 'vs_ai' ? 'AI ko' : 'Player 2 ko')} ongoing effect se ${damageAmount} IP damage hua.`, 4000);
                    logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ko ongoing effect se ${damageAmount} IP damage hua.`, 'game-event');
                }
                player.damageOverTime.turns--;
                if (player.damageOverTime.turns <= 0) {
                    player.damageOverTime.active = false;
                    logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ka Damage over time effect end hua.`, 'game-event');
                }
            }

            if (player.inGracePeriod && player.ip > 0) {
                player.inGracePeriod = false;
                player.graceRoundsRemaining = -1;
                showMessage(`${playerType === 'player1' ? 'Aapne' : 'Opponent ne'} 0 IP se recover kar liya hai!`, 5000);
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : 'Player 2'} has recovered from grace period.`, 'game-event');
            }
        }

        function renderHand(playerType, animateDraw = false) {
            const handDiv = document.getElementById(`${playerType}-hand`);
            const playAreaDiv = document.getElementById(`${playerType}-play-area`);

            Array.from(handDiv.children).forEach(child => {
                if (child.classList.contains('card')) {
                    child.remove();
                }
            });

            playAreaDiv.innerHTML = '';

            const handToRender = players[playerType].hand;
            handToRender.forEach((card, index) => {
                const cardElem = document.createElement('div');
                cardElem.className = `card ${card.type.toLowerCase()}`;
                if (animateDraw) {
                    cardElem.classList.add('drawing');
                    cardElem.style.animationDelay = `${index * 0.4}s`;
                }

                let displayCost = card.cost;
                const activeBranch = players[playerType].selectedBranch;
                if (activeBranch === 'Geometry' && card.type !== 'Action' && card.type !== 'Theorem') {
                    displayCost = card.cost + 1;
                }
                if (activeBranch === 'Complex Analysis' && card.type === 'Theorem' && (card.name === 'Swap IPs' || card.name === 'Invert IP Sign')) {
                    displayCost += 2;
                }

                cardElem.innerHTML = `
                <div class="card-top">
                    <span class="card-icon">${card.icon}</span>
                    <span class="card-name">${card.name}</span>
                </div>
                <span class="card-cost">Cost: ${displayCost}</span>
                <div class="card-summary-text">${card.summary}</div>
                <div class="card-description-text">${card.description}</div>
            `;

                cardElem.cardData = card;

                if (playerType === currentPlayer && (playerType === 'player1' || gameMode === 'vs_local_player')) {
                    cardElem.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        cardElem.classList.toggle('show-description');
                    });

                    cardElem.addEventListener('dblclick', (ev) => {
                        ev.stopPropagation();
                        playCard(card, cardElem, playerType);
                    });

                    cardElem.addEventListener('touchend', (ev) => {
                        const currentTime = new Date().getTime();
                        const tapLength = currentTime - lastTapTime;
                        if (tapLength < DOUBLE_TAP_THRESHOLD && tapLength > 0) {
                            playCard(card, cardElem, playerType);
                            lastTapTime = 0;
                        } else {
                            cardElem.classList.toggle('show-description');
                            lastTapTime = currentTime;
                        }
                        ev.preventDefault();
                    });
                    cardElem.style.pointerEvents = 'auto';
                    cardElem.style.opacity = '1';
                } else {
                    cardElem.innerHTML = `<div class="card-back" style="background-color: #333; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; font-size: 2em; border-radius: 10px;">?</div>`;
                    cardElem.style.cursor = 'default';
                    cardElem.style.pointerEvents = 'none';
                    cardElem.style.opacity = '0.5';
                }

                handDiv.appendChild(cardElem);
            });
        }

        async function playCard(card, cardElem, playerType) {
            if (currentPhase !== 'play' || currentPlayer !== playerType) {
                showMessage(`Aap sirf Play Phase mein aur apni baari mein cards play kar sakte ho!`, 8000);
                return;
            }
            if (!card) {
                showMessage('Card nahi mila.', 8000);
                return;
            }

            let actualCost = card.cost;
            const activeBranch = players[playerType].selectedBranch;
            if (activeBranch === 'Geometry' && card.type !== 'Action' && card.type !== 'Theorem') {
                actualCost = card.cost + 1;
            }
            if (activeBranch === 'Complex Analysis' && card.type === 'Theorem' && (card.name === 'Swap IPs' || card.name === 'Invert IP Sign')) {
                actualCost += 2;
            }

            if (players[playerType].tokens < actualCost) {
                showMessage(`Tokens kam hain! Is card ki cost ${actualCost} tokens hai.`, 8000);
                return;
            }
            players[playerType].tokens -= actualCost;

            const indexInHand = players[playerType].hand.indexOf(card);
            if (indexInHand > -1) {
                players[playerType].hand.splice(indexInHand, 1);
            } else {
                console.error("Card not found in hand during splice:", card.name);
                showMessage("Card ko hand se remove karne mein dikkat hui.", 8000);
                return;
            }

            if (cardElem) {
                const playAreaDiv = document.getElementById(`${playerType}-play-area`);
                playAreaDiv.appendChild(cardElem);
                cardElem.classList.add('playing');
                cardElem.addEventListener('animationend', () => {
                    cardElem.remove();
                    discardPile.push(card);
                    updateDeckDiscardCounts();
                }, {
                    once: true
                });
            } else {
                discardPile.push(card);
                updateDeckDiscardCounts();
            }

            playedCardsThisTurn.push(card);
            showMessage(`${playerType === 'player1' ? 'Aapne' : (gameMode === 'vs_ai' ? 'AI ne' : 'Player 2 ne')} "${card.name}" card play kiya!`, 4000);
            logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ne "${card.name}" card (Cost: ${actualCost}) play kiya.`, `${playerType}-action`);

            playSound('cardPlay');
            renderHand(playerType);
            updateStatus();
        }

        function factorial(n) {
            if (n < 0 || n % 1 !== 0) return NaN;
            if (n === 0) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
                if (result > Number.MAX_SAFE_INTEGER) {
                    showMessage("Factorial value bahut bada ho gaya!", 4000);
                    return Infinity;
                }
            }
            return result;
        }

        function lanczosGamma(z) {
            const p = [676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
            const g = 7;
            if (z < 0.5) {
                return Math.PI / (Math.sin(Math.PI * z) * lanczosGamma(1 - z));
            }
            z -= 1;
            let x = 0.99999999999980993;
            for (let i = 0; i < p.length; i++) {
                x += p[i] / (z + i + 1);
            }
            const t = z + g + 0.5;
            return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
        }

        function largestPrimeFactor(n) {
            n = Math.floor(Math.abs(n));
            if (n <= 1) return 1;
            let maxPrime = -1;
            while (n % 2 === 0) {
                maxPrime = 2;
                n /= 2;
            }
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                while (n % i === 0) {
                    maxPrime = i;
                    n = n / i;
                }
            }
            if (n > 2) {
                maxPrime = n;
            }
            return maxPrime;
        }
        
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        async function applyCardEffect(card, playerType) {
            const currentPlayerData = players[playerType];
            const opponentPlayerType = (playerType === 'player1' ? 'player2' : 'player1');
            const opponentPlayerData = players[opponentPlayerType];

            let targetPlayer = card.target === 'opponent' ? opponentPlayerData : currentPlayerData;
            let targetPlayerId = `${card.target === 'opponent' ? opponentPlayerType : playerType}-ip`;
            let selfPlayerId = `${playerType}-ip`;
            let valueToApply = card.value;

            const activeBranch = currentPlayerData.selectedBranch;
            const opponentBranch = opponentPlayerData.selectedBranch;

            let damageMultiplier = 1;
            if (currentPlayerData.doubleDamageNextTurn && card.target === 'opponent' &&
                (card.effect === 'direct_value_change' || card.effect === 'random_damage' || card.effect === 'ultimate_damage' || card.effect === 'prime_factor_damage' || card.effect === 'deal_damage_based_on_ip_diff' || card.effect === 'sine_wave_damage' || card.effect === 'secant_strike')) {
                damageMultiplier = 2;
                currentPlayerData.doubleDamageNextTurn = false;
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ka Double Damage effect use hua.`, 'game-event');
            }

            if (activeBranch === 'Number Theory' && card.type === 'Number' && Math.random() < 0.1) {
                showMessage(`${playerType === 'player1' ? 'Aapki' : (gameMode === 'vs_ai' ? 'AI ki' : 'Player 2 ki')} Number Theory ki unpredictable nature! ${playerType === 'player1' ? 'Aapke' : (gameMode === 'vs_ai' ? 'AI ke' : 'Player 2 ke')} ${card.name} ne 0 damage kiya.`, 4500);
                logGameEvent(`${playerType === 'player1' ? 'Player 1' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2')} ka "${card.name}" card (Number Theory con) ne 0 effect kiya.`, `${playerType}-action`);
                updateStatus();
                return;
            }
            if (activeBranch === 'Algebra' && card.type === 'Number' && card.effect === 'direct_value_change') {
                if (card.target === 'opponent') valueToApply += 1;
                else if (card.target === 'self' && card.value < 0) valueToApply -= 1;
            }
            if (activeBranch === 'Probability' && card.effect === 'random_damage') {
                valueToApply = {
                    min: card.value.min,
                    max: card.value.max + Math.floor((card.value.max - card.value.min) * 0.5)
                };
            }

            switch (card.effect) {
                case 'direct_value_change':
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Imaginary IP par simple +/- kaam nahi karta!`, 4000);
                        break;
                    }
                    const actualDirectValue = valueToApply * damageMultiplier;
                    if (card.target === 'opponent') {
                        targetPlayer.ip -= actualDirectValue;
                        showFloatingText(actualDirectValue, 'damage', targetPlayerId);
                        playSound('damage');
                    } else if (card.target === 'self') {
                        targetPlayer.ip += actualDirectValue;
                        showFloatingText(actualDirectValue, actualDirectValue > 0 ? 'heal' : 'damage', selfPlayerId);
                        playSound(actualDirectValue > 0 ? 'heal' : 'damage');
                    }
                    break;
                case 'multiply_ip':
                case 'divide_ip':
                    if (card.effect === 'divide_ip' && targetPlayer.ip === 0) {
                        showMessage('Zero se divide nahi kar sakte!', 3000);
                        break;
                    }
                    let multiplier = valueToApply;
                    if (opponentBranch === 'Trigonometry') {
                        multiplier = (card.effect === 'multiply_ip') ? multiplier * 1.25 : multiplier / 1.25;
                    }
                    targetPlayer.ip = (card.effect === 'multiply_ip') ? targetPlayer.ip * multiplier : targetPlayer.ip / multiplier;
                    break;
                case 'square_ip':
                    if (targetPlayer.isIPImaginary) {
                        targetPlayer.ip = -(targetPlayer.ip * targetPlayer.ip);
                        targetPlayer.isIPImaginary = false;
                        showMessage(`Imaginary IP ka square kiya, real aur negative ho gaya!`, 4000);
                        playSound('damage');
                    } else {
                        targetPlayer.ip *= targetPlayer.ip;
                    }
                    break;
                case 'negative_imaginary_square':
                    if (targetPlayer.isIPImaginary) {
                        targetPlayer.ip = -(targetPlayer.ip * targetPlayer.ip);
                        targetPlayer.isIPImaginary = false;
                        showMessage(`Imaginary IP ka square karke usse negative real bana diya!`, 4000);
                        playSound('damage');
                    } else {
                         showMessage(`Target ka IP imaginary nahi hai, koi asar nahi hua.`, 3000);
                    }
                    break;
                case 'imaginary_annihilation':
                    if (targetPlayer.isIPImaginary) {
                        targetPlayer.ip = -targetPlayer.ip;
                        targetPlayer.isIPImaginary = false;
                        showMessage(`Imaginary Annihilation! Opponent ka IP ab negative real hai!`, 5000);
                        playSound('damage');
                    } else {
                        showMessage(`Target ka IP imaginary nahi hai, koi asar nahi hua.`, 3000);
                    }
                    break;
                case 'eulers_transformation':
                     const oldEulerIP = targetPlayer.ip;
                     targetPlayer.ip = Math.cos(toRadians(oldEulerIP));
                     targetPlayer.isIPImaginary = false;
                     targetPlayer.isIPIrrational = true; // cos of most numbers is irrational
                     showMessage(`Euler's Transformation! Opponent ka IP ab ${targetPlayer.ip.toFixed(2)} ho gaya hai!`, 5000);
                     playSound('damage');
                     break;
                case 'de_moivres_gambit':
                    if (targetPlayer.isIPImaginary) {
                        const power = Math.floor(Math.random() * 4) + 2; // Random power from 2 to 5
                        const oldDeMoivreIP = targetPlayer.ip;
                        // (i*x)^n = i^n * x^n
                        // i^2=-1, i^3=-i, i^4=1, i^5=i
                        let newIP = Math.pow(oldDeMoivreIP, power);
                        let newIsImaginary = false;
                        
                        switch (power % 4) {
                            case 0: // i^4 = 1
                                targetPlayer.ip = newIP;
                                newIsImaginary = false;
                                break;
                            case 1: // i^5 = i
                                targetPlayer.ip = newIP;
                                newIsImaginary = true;
                                break;
                            case 2: // i^2 = -1
                                targetPlayer.ip = -newIP;
                                newIsImaginary = false;
                                break;
                            case 3: // i^3 = -i
                                targetPlayer.ip = -newIP;
                                newIsImaginary = true;
                                break;
                        }
                        targetPlayer.isIPImaginary = newIsImaginary;
                        showMessage(`De Moivre's Gambit! Opponent ka IP power ${power} se badal gaya!`, 5000);
                        playSound('damage');
                    } else {
                        showMessage(`Target ka IP imaginary nahi hai, koi asar nahi hua.`, 3000);
                    }
                    break;
                case 'square_root_ip':
                    if (targetPlayer.isIPImaginary || targetPlayer.ip < 0) {
                        showMessage('Negative ya Imaginary IP ka square root nahi le sakte!', 3000);
                        break;
                    }
                    targetPlayer.ip = Math.sqrt(targetPlayer.ip);
                    break;
                case 'absolute_value_ip':
                    if (targetPlayer.isIPImaginary) {
                        targetPlayer.isIPImaginary = false;
                        showMessage(`Aapne apne imaginary IP ko real banaya!`, 4000);
                    }
                    targetPlayer.ip = Math.abs(targetPlayer.ip);
                    break;
                case 'derivative_effect':
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Imaginary IP ka derivative complex hai, koi asar nahi hua!`, 4000);
                        break;
                    }
                    targetPlayer.ip = 0;
                    break;
                // ... (rest of the card effects remain the same)
                 case 'logarithm_effect':
                    if (targetPlayer.isIPImaginary || targetPlayer.ip <= 0) {
                        showMessage('Logarithm ke liye IP positive real number hona chahiye!', 4000);
                        break;
                    }
                    targetPlayer.ip = Math.log(targetPlayer.ip);
                    break;
                case 'reciprocal_ip':
                    if (targetPlayer.ip === 0) {
                        showMessage('Zero ka reciprocal nahi le sakte!', 3000);
                        break;
                    }
                    if (targetPlayer.isIPImaginary) {
                        targetPlayer.ip = -1 / targetPlayer.ip;
                    } else {
                        targetPlayer.ip = 1 / targetPlayer.ip;
                    }
                    break;
                case 'power_of_zero':
                    if (targetPlayer.ip === 0) {
                        showMessage('0^0 undefined hai!', 3000);
                        break;
                    }
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Imaginary IP ki power 0 complex hai, koi asar nahi hua!`, 4000);
                        break;
                    }
                    targetPlayer.ip = 1;
                    break;
                case 'factorial_ip':
                    if (targetPlayer.isIPImaginary || targetPlayer.ip < 0 || targetPlayer.ip > 12 || targetPlayer.ip % 1 !== 0) {
                        showMessage(`Factorial sirf 0-12 ke beech ke real integers par kaam karta hai!`, 4000);
                        break;
                    }
                    targetPlayer.ip = factorial(Math.floor(targetPlayer.ip));
                    break;
                case 'gamma_function_ip':
                    if (targetPlayer.isIPImaginary || targetPlayer.ip <= 0) {
                        showMessage(`Gamma Function sirf positive real numbers par kaam karta hai!`, 4000);
                        break;
                    }
                    targetPlayer.ip = lanczosGamma(targetPlayer.ip);
                    break;
                case 'divide_by_pi':
                    if (targetPlayer.ip === 0) {
                        showMessage('Zero ko Pi se divide nahi kar sakte!', 3000);
                        break;
                    }
                    targetPlayer.ip /= Math.PI;
                    targetPlayer.isIPIrrational = true;
                    targetPlayer.isIPImaginary = false;
                    break;
                case 'swap_ips':
                    [players.player1.ip, players.player2.ip] = [players.player2.ip, players.player1.ip];
                    [players.player1.isIPIrrational, players.player2.isIPIrrational] = [players.player2.isIPIrrational, players.player1.isIPIrrational];
                    [players.player1.isIPImaginary, players.player2.isIPImaginary] = [players.player2.isIPImaginary, players.player1.isIPImaginary];
                    if (currentPlayerData.selectedBranch === 'Complex Analysis') {
                        currentPlayerData.ip += 10;
                    }
                    break;
                case 'natural_number_set_effect':
                    if (targetPlayer.isIPIrrational) {
                        targetPlayer.ip = 0;
                        targetPlayer.isIPIrrational = false;
                    } else {
                        showMessage(`${card.target === 'opponent' ? 'Opponent' : 'Aapka'} IP irrational nahi hai.`, 3000);
                    }
                    break;
                case 'rotate_to_imaginary':
                    if (targetPlayer.isIPImaginary) {
                        targetPlayer.ip = -targetPlayer.ip;
                        targetPlayer.isIPImaginary = false;
                    } else {
                        targetPlayer.isIPImaginary = true;
                        targetPlayer.isIPIrrational = false;
                    }
                    break;
                case 'real_projection':
                    if (targetPlayer.isIPImaginary) {
                        targetPlayer.ip = 0;
                        targetPlayer.isIPImaginary = false;
                    } else {
                        showMessage(`${card.target === 'opponent' ? 'Opponent' : 'Aapka'} IP imaginary nahi hai.`, 3000);
                    }
                    break;
                case 'prime_factor_damage':
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Imaginary IP ka prime factor nahi nikal sakte!`, 4000);
                        break;
                    }
                    const ipIntPrime = Math.floor(Math.abs(targetPlayer.ip));
                    const damagePrime = largestPrimeFactor(ipIntPrime) * damageMultiplier;
                    if (damagePrime > 0) {
                        targetPlayer.ip -= damagePrime;
                    } else {
                        showMessage(`IP ka koi prime factor nahi mila, koi damage nahi hua.`, 3000);
                    }
                    break;
                case 'block_damage':
                    if (card.target === 'self') {
                        currentPlayerData.blockDamage += valueToApply;
                    }
                    break;
                case 'draw_card':
                    await drawCard(playerType, valueToApply);
                    break;
                case 'random_damage':
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Random damage ka imaginary IP par koi asar nahi hua!`, 4000);
                        break;
                    }
                    const damageRand = Math.floor(Math.random() * (valueToApply.max - valueToApply.min + 1)) + valueToApply.min;
                    const actualDamageRand = damageRand * damageMultiplier;
                    if (card.target === 'opponent') {
                        opponentPlayerData.ip -= actualDamageRand;
                    } else if (card.target === 'self') {
                        currentPlayerData.ip -= actualDamageRand;
                    }
                    break;
                case 'copy_ip':
                    currentPlayerData.ip = opponentPlayerData.ip;
                    currentPlayerData.isIPIrrational = opponentPlayerData.isIPIrrational;
                    currentPlayerData.isIPImaginary = opponentPlayerData.isIPImaginary;
                    break;
                case 'steal_token':
                    const stolenAmount = valueToApply;
                    if (card.target === 'opponent') {
                        const actualStolen = Math.min(stolenAmount, opponentPlayerData.tokens);
                        currentPlayerData.tokens += actualStolen;
                        opponentPlayerData.tokens -= actualStolen;
                    }
                    break;
                case 'one_hit_ko_chance':
                    if (Math.random() < 0.5) {
                        if (targetPlayer.isIPImaginary) {
                            showMessage(`Imaginary IP par Euler's Identity ka asar complex hai, koi asar nahi hua!`, 4000);
                            break;
                        }
                        targetPlayer.ip = 1;
                    } else {
                        showMessage(`${playerType === 'player1' ? 'Aapne' : (gameMode === 'vs_ai' ? 'AI ne' : 'Player 2 ne')} ${card.name} activate kiya! Lekin is baar koi effect nahi hua.`, 4500);
                    }
                    break;
                case 'heal_over_time':
                case 'damage_over_time':
                    let duration = card.turns;
                    if (activeBranch === 'Calculus') {
                        duration += 1;
                    }
                    let effectType = card.effect === 'heal_over_time' ? 'healOverTime' : 'damageOverTime';
                    let targetObject = card.target === 'self' ? currentPlayerData : opponentPlayerData;
                    targetObject[effectType] = { active: true, value: valueToApply, turns: duration };
                    break;
                case 'double_damage_next_turn':
                    if (card.target === 'self') {
                        currentPlayerData.doubleDamageNextTurn = true;
                    }
                    break;
                case 'ultimate_damage':
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Ultimate damage ka imaginary IP par koi asar nahi hua!`, 4000);
                        break;
                    }
                    const actualUltimateValue = valueToApply * damageMultiplier;
                    if (card.target === 'opponent') {
                        opponentPlayerData.ip -= actualUltimateValue;
                    } else if (card.target === 'self') {
                        currentPlayerData.ip -= actualUltimateValue;
                    }
                    break;
                case 'discard_hand':
                    let targetHand = card.target === 'opponent' ? opponentPlayerData.hand : currentPlayerData.hand;
                    discardPile.push(...targetHand);
                    targetHand.length = 0;
                    if (card.target === 'opponent' && gameMode === 'vs_local_player') renderHand('player2');
                    else if (card.target === 'self') renderHand('player1');
                    break;
                case 'reflect_damage':
                    if (card.target === 'self') {
                        currentPlayerData.reflectDamage = { active: true, value: valueToApply, turns: card.turns };
                    }
                    break;
                 case 'sine_wave_damage':
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Damage ka imaginary IP par koi asar nahi hua!`, 4000);
                        break;
                    }
                    const sineDamage = (valueToApply * Math.sin(toRadians(currentPlayerData.angle))) * damageMultiplier;
                    targetPlayer.ip -= sineDamage;
                    break;
                case 'cosine_shield':
                    const blockAmount = valueToApply * Math.cos(toRadians(currentPlayerData.angle));
                    currentPlayerData.blockDamage += blockAmount;
                    break;
                case 'deal_damage_based_on_ip_diff':
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Damage ka imaginary IP par koi asar nahi hua!`, 4000);
                        break;
                    }
                    const ipDifference = Math.abs(currentPlayerData.ip - opponentPlayerData.ip);
                    const damageFromDiff = (ipDifference * (0.5 + 0.2 * Math.cos(toRadians(currentPlayerData.angle)))) * damageMultiplier;
                    targetPlayer.ip -= damageFromDiff;
                    break;
                case 'secant_strike':
                    if (targetPlayer.isIPImaginary) {
                        showMessage(`Damage ka imaginary IP par koi asar nahi hua!`, 4000);
                        break;
                    }
                    const cosAngle = Math.cos(toRadians(currentPlayerData.angle));
                    if (Math.abs(cosAngle) < 0.001) {
                         showMessage(`Secant Strike ka angle 90° ke bahut paas hai, effect fail hua!`, 4000);
                         break;
                    }
                    const secantDamage = (valueToApply / cosAngle) * damageMultiplier;
                    targetPlayer.ip -= secantDamage;
                    break;
                default:
                    console.warn(`Unhandled card effect: ${card.effect}`);
            }
            updateStatus();
        }

        async function simulateAITurn() {
            const playerType = 'player2';
            logGameEvent('AI apna turn khel raha hai...', 'game-event');
            await new Promise(resolve => setTimeout(resolve, 1000));

            if (players[playerType].inGracePeriod) {
                players[playerType].graceRoundsRemaining--;
                showMessage(`AI ke grace period ke ${players[playerType].graceRoundsRemaining} turn bache hain!`, 4000);
                logGameEvent(`AI is in grace period. ${players[playerType].graceRoundsRemaining} turns left.`, 'game-event');
            }
            if (checkGameEnd()) return;

            currentPhase = 'draw';
            updatePhaseDisplay();
            playedCardsThisTurn = [];
            applyPerTurnEffects(playerType);
            await drawCard(playerType, AI_CARDS_TO_DRAW_PER_TURN);
            await new Promise(resolve => setTimeout(resolve, 1500));

            currentPhase = 'play';
            updatePhaseDisplay();
            showMessage('AI apne cards play kar raha hai...', 3000);

            let aiPlayLogic;
            switch (aiDifficulty) {
                case 'easy':
                    aiPlayLogic = getEasyAIPlay;
                    break;
                case 'hard':
                    aiPlayLogic = getHardAIPlay;
                    break;
                case 'medium':
                default:
                    aiPlayLogic = getMediumAIPlay;
                    break;
            }
            
            if (players.player2.selectedBranch === 'Trigonometry') {
                setAIAngle();
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            await aiPlayLogic();
            logGameEvent('AI ne apne cards play kar liye.', 'game-event');
            await new Promise(resolve => setTimeout(resolve, 2000));

            currentPhase = 'battle';
            updatePhaseDisplay();
            showMessage('AI ke cards ke effects resolve ho rahe hain!', 4000);
            await resolveBattlePhase(playerType);
            if (checkGameEnd()) return;

            await applyGeneralAttack(playerType);
            if (checkGameEnd()) return;
            await new Promise(resolve => setTimeout(resolve, 2000));

            currentPhase = 'heal';
            updatePhaseDisplay();
            showMessage('AI ki Heal Phase: Ongoing effects apply ho rahe hain.', 4000);
            await applyHealDamageOverTime(playerType);
            if (checkGameEnd()) return;
            await new Promise(resolve => setTimeout(resolve, 2000));

            updateStatus();
            if (checkGameEnd()) return;
            logGameEvent('AI ka turn khatam hua.', 'game-event');
        }
        
        function setAIAngle() {
            let bestAngle = 45;
            let maxScore = -Infinity;
            const testAngles = [0, 30, 45, 60, 85, 90];

            for (const angle of testAngles) {
                let currentScore = 0;
                for (const card of players.player2.hand) {
                    if (card.branch === 'Trigonometry') {
                        switch (card.effect) {
                            case 'sine_wave_damage':
                                currentScore += card.value * Math.sin(toRadians(angle));
                                break;
                            case 'cosine_shield':
                                const healthMultiplier = (players.player2.ip < 50) ? 1.5 : 1;
                                currentScore += card.value * Math.cos(toRadians(angle)) * healthMultiplier;
                                break;
                            case 'secant_strike':
                                const cosAngle = Math.cos(toRadians(angle));
                                if (Math.abs(cosAngle) > 0.01) {
                                    currentScore += card.value / cosAngle;
                                }
                                break;
                        }
                    }
                }
                if (currentScore > maxScore) {
                    maxScore = currentScore;
                    bestAngle = angle;
                }
            }
            players.player2.angle = bestAngle;
            document.getElementById('player2-angle-slider').value = bestAngle;
            document.getElementById('player2-angle-value').textContent = bestAngle;
            showMessage(`AI ne apna angle ${bestAngle}° par set kiya.`, 3000);
            logGameEvent(`AI ne apna angle ${bestAngle}° par set kiya.`, 'player2-action');
        }

        async function getEasyAIPlay() {
            const aiHand = [...players.player2.hand];
            for (const card of aiHand) {
                let actualCost = card.cost;
                if (players.player2.selectedBranch === 'Geometry' && card.type !== 'Action' && card.type !== 'Theorem') {
                    actualCost += 1;
                }
                if (players.player2.selectedBranch === 'Complex Analysis' && card.type === 'Theorem' && (card.name === 'Swap IPs' || card.name === 'Invert IP Sign')) {
                    actualCost += 2;
                }
                if (players.player2.tokens >= actualCost) {
                    await playCard(card, null, 'player2');
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    if (isGameOver) return;
                }
            }
        }

        async function getMediumAIPlay() {
            const scoredCards = scoreCardsForAI();
            for (const item of scoredCards) {
                const card = item.card;
                let actualCost = card.cost;
                if (players.player2.selectedBranch === 'Geometry' && card.type !== 'Action' && card.type !== 'Theorem') actualCost += 1;
                if (players.player2.selectedBranch === 'Complex Analysis' && card.type === 'Theorem' && (card.name === 'Swap IPs' || card.name === 'Invert IP Sign')) actualCost += 2;

                if (players.player2.tokens >= actualCost) {
                    await playCard(card, null, 'player2');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    if (isGameOver) return;
                }
            }
        }

        async function getHardAIPlay() {
            while (true) {
                const scoredCards = scoreCardsForAI(true);
                if (scoredCards.length === 0 || scoredCards[0].score < 10) {
                    break;
                }
                const bestCardItem = scoredCards[0];
                const card = bestCardItem.card;
                let actualCost = card.cost;
                if (players.player2.selectedBranch === 'Geometry' && card.type !== 'Action' && card.type !== 'Theorem') actualCost += 1;
                if (players.player2.selectedBranch === 'Complex Analysis' && card.type === 'Theorem' && (card.name === 'Swap IPs' || card.name === 'Invert IP Sign')) actualCost += 2;

                if (players.player2.tokens >= actualCost) {
                    await playCard(card, null, 'player2');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    if (isGameOver) return;
                } else {
                    break;
                }
            }
        }

        function scoreCardsForAI(isHard = false) {
            const calculateEffectiveValue = (card, playerType) => {
                let value = 0;
                let isDamage = false, isHeal = false;
                const angle = players[playerType].angle;

                if (card.effect === 'direct_value_change') {
                    value = card.value;
                    if (card.target === 'opponent') isDamage = true;
                    else isHeal = true;
                } else if (card.effect === 'random_damage') {
                    value = (card.value.min + card.value.max) / 2;
                    isDamage = true;
                } else if (card.effect === 'ultimate_damage') {
                    value = card.value;
                    isDamage = true;
                } else if (card.effect === 'heal_over_time' && card.target === 'self') {
                    value = card.value * (card.turns + (players[playerType].selectedBranch === 'Calculus' ? 1 : 0));
                    isHeal = true;
                } else if (card.effect === 'damage_over_time' && card.target === 'opponent') {
                    value = card.value * (card.turns + (players[playerType].selectedBranch === 'Calculus' ? 1 : 0));
                    isDamage = true;
                } else if (card.effect === 'natural_number_set_effect' && players.player1.isIPIrrational) {
                    value = players.player1.ip;
                    isDamage = true;
                } else if (card.effect === 'swap_ips') {
                    if (players.player2.ip < players.player1.ip) {
                        value = players.player1.ip - players.player2.ip;
                        isHeal = true;
                    } else {
                        value = players.player2.ip - players.player1.ip;
                        isDamage = true;
                    }
                } else if (card.effect === 'invert_sign_ip' && card.target === 'opponent') {
                    value = players.player1.ip * 2;
                    isDamage = true;
                } else if (card.effect === 'rotate_to_imaginary' && card.target === 'opponent' && !players.player1.isIPImaginary) {
                    value = 50;
                    isDamage = true;
                } else if (card.effect === 'real_projection' && card.target === 'opponent' && players.player1.isIPImaginary) {
                    value = players.player1.ip;
                    isDamage = true;
                } else if (card.effect === 'prime_factor_damage') {
                    value = largestPrimeFactor(players.player1.ip);
                    isDamage = true;
                } else if (card.effect === 'deal_damage_based_on_ip_diff') {
                    value = Math.abs(players.player1.ip - players.player2.ip) * (0.5 + 0.2 * Math.cos(toRadians(angle)));
                    isDamage = true;
                } else if (card.effect === 'sine_wave_damage') {
                    value = card.value * Math.sin(toRadians(angle));
                    isDamage = true;
                } else if (card.effect === 'cosine_shield') {
                    value = card.value * Math.cos(toRadians(angle));
                    isHeal = true;
                } else if (card.effect === 'secant_strike') {
                    const cosAngle = Math.cos(toRadians(angle));
                    if (Math.abs(cosAngle) > 0.01) {
                        value = card.value / cosAngle;
                    }
                    isDamage = true;
                }

                if (isDamage && players[playerType].doubleDamageNextTurn) {
                    value *= 2;
                }
                return { value, isDamage, isHeal };
            };

            const scoredCards = players.player2.hand.map(card => {
                let score = 0;
                let actualCost = card.cost;
                if (players.player2.selectedBranch === 'Geometry' && card.type !== 'Action' && card.type !== 'Theorem') actualCost += 1;
                if (players.player2.selectedBranch === 'Complex Analysis' && card.type === 'Theorem' && (card.name === 'Swap IPs' || card.name === 'Invert IP Sign')) actualCost += 2;

                if (players.player2.tokens < actualCost) return { card, score: -Infinity };
                const { value: effectiveValue, isDamage, isHeal } = calculateEffectiveValue(card, 'player2');

                if (isDamage && (players.player1.ip - effectiveValue <= 0) && !players.player1.inGracePeriod) score += 1000;
                if (card.effect === 'natural_number_set_effect' && players.player1.isIPIrrational) score += 900;

                let healthUrgency = 0;
                if (players.player2.ip <= 25 || players.player2.inGracePeriod) healthUrgency = 5;
                else if (players.player2.ip <= 50) healthUrgency = 2;

                if (isHeal) score += effectiveValue * healthUrgency;
                if (card.effect === 'block_damage' || card.effect === 'cosine_shield') score += effectiveValue * (healthUrgency > 0 ? 4 : 1);
                if (card.effect === 'reflect_damage') score += 20 * healthUrgency;
                if (card.effect === 'swap_ips' && isHeal) score += effectiveValue * healthUrgency;

                if (isDamage) score += effectiveValue * 1.5;
                if (card.effect === 'discard_hand') score += players.player1.hand.length * 20;
                if (card.effect === 'steal_token' && players.player1.tokens > 3) score += card.value * 25;

                if (isHard) {
                    const hasBigDamageCard = players.player2.hand.some(c => c.effect === 'ultimate_damage' || c.effect === 'prime_factor_damage' || c.effect === 'secant_strike');
                    if (card.effect === 'double_damage_next_turn' && hasBigDamageCard) score += 150;
                    else if (card.effect === 'double_damage_next_turn') score += 60;
                    if (card.effect === 'real_projection' && players.player1.isIPImaginary) score += 200;
                    if (card.effect === 'natural_number_set_effect' && players.player1.isIPIrrational) score += 300;
                    if (card.effect === 'swap_ips' && players.player2.ip > players.player1.ip + 30) score -= 200;
                } else {
                    if (card.effect === 'double_damage_next_turn') score += 50;
                }

                if (card.effect === 'draw_card') score += 20;
                score -= actualCost * 2;

                return { card, score };
            });

            return scoredCards.filter(item => item.score > -Infinity).sort((a, b) => b.score - a.score);
        }

        function updateStatus() {
            document.getElementById('player1-ip').textContent = players.player1.ip.toFixed(2);
            document.getElementById('player2-ip').textContent = players.player2.ip.toFixed(2);
            document.getElementById('player1-tokens').textContent = players.player1.tokens;
            document.getElementById('player2-tokens').textContent = players.player2.tokens;

            const player1IPFill = document.getElementById('player1-ip-fill');
            const player2IPFill = document.getElementById('player2-ip-fill');
            const player1IrrationalIndicator = document.getElementById('player1-irrational-indicator');
            const player2IrrationalIndicator = document.getElementById('player2-irrational-indicator');
            const player1ImaginaryIndicator = document.getElementById('player1-imaginary-indicator');
            const player2ImaginaryIndicator = document.getElementById('player2-imaginary-indicator');

            let player1Percentage = (players.player1.ip / 100) * 100;
            let player2Percentage = (players.player2.ip / 100) * 100;

            player1IPFill.style.width = `${Math.max(0, player1Percentage)}%`;
            player2IPFill.style.width = `${Math.max(0, player2Percentage)}%`;

            player1IPFill.classList.remove('low', 'medium');
            if (players.player1.ip <= 20) player1IPFill.classList.add('low');
            else if (players.player1.ip <= 50) player1IPFill.classList.add('medium');

            player2IPFill.classList.remove('low', 'medium');
            if (players.player2.ip <= 20) player2IPFill.classList.add('low');
            else if (players.player2.ip <= 50) player2IPFill.classList.add('medium');

            player1IrrationalIndicator.style.display = players.player1.isIPIrrational ? 'inline' : 'none';
            player2IrrationalIndicator.style.display = players.player2.isIPIrrational ? 'inline' : 'none';

            player1ImaginaryIndicator.style.display = players.player1.isIPImaginary ? 'inline' : 'none';
            player2ImaginaryIndicator.style.display = players.player2.isIPImaginary ? 'inline' : 'none';

            if (players.player1.ip <= 0 && !players.player1.inGracePeriod) {
                players.player1.inGracePeriod = true;
                players.player1.graceRoundsRemaining = 4;
                showMessage('Aapka IP 0 ho gaya! Aap ab 2-round grace period mein hain. Heal karo!', 8000);
                logGameEvent('Player 1 entered grace period.', 'game-event');
            }
            if (players.player2.ip <= 0 && !players.player2.inGracePeriod) {
                players.player2.inGracePeriod = true;
                players.player2.graceRoundsRemaining = 4;
                showMessage(`${gameMode === 'vs_ai' ? 'AI' : 'Player 2'} ka IP 0 ho gaya! Woh ab 2-round grace period mein hain.`, 8000);
                logGameEvent('Player 2 entered grace period.', 'game-event');
            }

            document.getElementById('player1-ip').classList.add('pulse');
            document.getElementById('player2-ip').classList.add('pulse');
            setTimeout(() => {
                document.getElementById('player1-ip').classList.remove('pulse');
                document.getElementById('player2-ip').classList.remove('pulse');
            }, 1200);
        }

        function updatePhaseDisplay() {
            const phaseDisplay = document.getElementById('current-phase-display');
            let phaseText = '';
            let playerText = currentPlayer === 'player1' ? 'Aapki' : (gameMode === 'vs_ai' ? 'AI ki' : 'Player 2 ki');
            switch (currentPhase) {
                case 'draw':
                    phaseText = `${playerText} Draw Phase (Cards draw ho rahe hain...)`;
                    break;
                case 'play':
                    phaseText = `${playerText} Play Phase (Cards play karne ke liye double tap karo)`;
                    break;
                case 'battle':
                    phaseText = `${playerText} Battle Phase (Effects resolve ho rahe hain)`;
                    break;
                case 'heal':
                    phaseText = `${playerText} Heal Phase (Ongoing effects apply ho rahe hain)`;
                    break;
            }
            phaseDisplay.textContent = `Current Phase: ${phaseText}`;
        }

        function updateDeckDiscardCounts() {
            document.getElementById('deck-count').textContent = deck.length;
            document.getElementById('discard-count').textContent = discardPile.length;
            document.getElementById('deck-pile').classList.toggle('empty', deck.length === 0);
            document.getElementById('discard-pile').classList.toggle('empty', discardPile.length === 0);
        }

        function checkGameEnd() {
            if (isGameOver) return true;
            let winner = null;
            let loser = null;

            if (players.player1.inGracePeriod && players.player1.graceRoundsRemaining <= 0) {
                if (players.player1.ip <= 0) {
                    winner = 'player2';
                    loser = 'player1';
                }
            }
            if (players.player2.inGracePeriod && players.player2.graceRoundsRemaining <= 0) {
                if (players.player2.ip <= 0) {
                    if (winner === 'player2' && players.player2.ip > players.player1.ip) {
                        winner = 'player2';
                        loser = 'player1';
                    } else {
                        winner = 'player1';
                        loser = 'player2';
                    }
                }
            }

            if (winner) {
                isGameOver = true;
                const winnerName = winner === 'player1' ? 'Aap' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2');
                const loserName = loser === 'player1' ? 'Aap' : (gameMode === 'vs_ai' ? 'AI' : 'Player 2');
                const message = `${winnerName} jeet gaye! ${loserName} grace period mein recover nahi kar paaye.`;
                showMessage(message, 10000);
                logGameEvent(`GAME OVER: ${winnerName} won.`, 'game-event');
                playSound(winner === 'player1' ? 'win' : 'lose');
                setTimeout(resetGame, 6000);
                return true;
            }
            return false;
        }

        function resetGame() {
            const createPlayerState = () => ({
                ip: 100.0,
                tokens: 10,
                hand: [],
                blockDamage: 0,
                damageOverTime: { active: false, value: 0, turns: 0 },
                healOverTime: { active: false, value: 0, turns: 0 },
                doubleDamageNextTurn: false,
                reflectDamage: { active: false, value: 0, turns: 0 },
                isIPIrrational: false,
                isIPImaginary: false,
                selectedBranch: '',
                inGracePeriod: false,
                graceRoundsRemaining: -1,
                angle: 45
            });
            players.player1 = createPlayerState();
            players.player2 = createPlayerState();
            isGameOver = false;
            currentTurn = 0;
            currentPlayer = 'player1';
            deck = [];
            discardPile = [];
            playedCardsThisTurn = [];
            chatHistory = [];
            gameHistoryLog = [];

            if (playerSynth) {
                Tone.Transport.stop();
                Tone.Transport.cancel();
                playerSynth.dispose();
                playerSynth = null;
            }
            if (damageSound) damageSound.dispose();
            if (healSound) healSound.dispose();
            if (cardDrawSound) cardDrawSound.dispose();
            if (cardPlaySound) cardPlaySound.dispose();
            if (winSound) winSound.dispose();
            if (loseSound) loseSound.dispose();

            document.getElementById('game-mode-select').style.display = 'flex';
            document.getElementById('branch-select').style.display = 'flex';
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('branch-effect-display-player1').style.display = 'none';
            document.getElementById('branch-effect-display-player2').style.display = 'none';
            
            document.getElementById('player1-hand').innerHTML = 'Aapka Hand (Card description ke liye single tap, play karne ke liye double tap)';
            document.getElementById('player1-play-area').innerHTML = 'Aapka Play Area (Played cards yahan dikhenge)';
            document.getElementById('player2-hand').innerHTML = "Player 2's Hand";
            document.getElementById('player2-play-area').innerHTML = "Player 2's Play Area";

            document.getElementById('end-play-phase-button').textContent = 'End Play Phase';
            document.getElementById('end-turn-button').textContent = 'End Turn';

            updateStatus();
            updateDeckDiscardCounts();
            displayBranchEffects('player1');
            displayBranchEffects('player2');
            toggleSetupVisibility();
        }

        function displayBranchEffects(playerNum) {
            const branch = document.getElementById(`branch-${playerNum}`).value;
            const effects = branchEffects[branch];
            const displayDiv = document.getElementById(`branch-effect-display-${playerNum}`);
            if (effects) {
                displayDiv.innerHTML = `
                <h4>${branch} Branch Effects (${playerNum === 'player1' ? 'Aapka' : 'Player 2 ka'}):</h4>
                <p><strong>Pros:</strong> ${effects.pros}</p>
                <p><strong>Cons:</strong> ${effects.cons}</p>
            `;
                displayDiv.style.display = 'block';
            } else {
                displayDiv.style.display = 'none';
            }
        }

        function openHelpModal() {
            document.getElementById('help-modal').classList.add('show');
            populateHelpModal();
        }

        function closeHelpModal() {
            document.getElementById('help-modal').classList.remove('show');
        }

        function populateHelpModal() {
            const modalBranchList = document.getElementById('modal-branch-effects-list');
            modalBranchList.innerHTML = '';
            for (const branch in branchEffects) {
                const effects = branchEffects[branch];
                const branchDiv = document.createElement('div');
                branchDiv.className = 'branch-info';
                branchDiv.innerHTML = `
                <h4>${branch}:</h4>
                <p><strong>Pros:</strong> ${effects.pros}</p>
                <p><strong>Cons:</strong> ${effects.cons}</p>
            `;
                modalBranchList.appendChild(branchDiv);
            }

            const cardPowersList = document.getElementById('card-powers-list');
            cardPowersList.innerHTML = '';
            allCards.sort((a, b) => a.name.localeCompare(b.name)).forEach(card => {
                const cardInfoDiv = document.createElement('div');
                cardInfoDiv.className = 'card-info';
                cardInfoDiv.innerHTML = `
                <strong>${card.name}</strong> (${card.icon}) (Type: ${card.type}) (Cost: ${card.cost})<br>
                ${card.description}
            `;
                cardPowersList.appendChild(cardInfoDiv);
            });
        }

        function openGameHistoryModal() {
            document.getElementById('game-history-modal').classList.add('show');
            updateGameHistoryDisplay();
        }

        function closeGameHistoryModal() {
            document.getElementById('game-history-modal').classList.remove('show');
        }

        function updateGameHistoryDisplay() {
            const historyLogDiv = document.getElementById('game-history-log');
            historyLogDiv.innerHTML = '';
            gameHistoryLog.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = `history-entry ${entry.type}`;
                entryDiv.innerHTML = `<strong>Turn ${entry.turn} (${entry.phase}):</strong> ${entry.message}`;
                historyLogDiv.appendChild(entryDiv);
            });
            historyLogDiv.scrollTop = historyLogDiv.scrollHeight;
        }

        function openChatbotModal() {
            const modal = document.getElementById('chatbot-modal');
            modal.classList.add('show');
            document.getElementById('chat-input').focus();
            const chatHistoryDiv = document.getElementById('chat-history-display');
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        }

        function closeChatbotModal() {
            document.getElementById('chatbot-modal').classList.remove('show');
        }

        async function sendChatMessage() {
            const chatInput = document.getElementById('chat-input');
            const userMessage = chatInput.value.trim();
            if (!userMessage) return;
            
            if (!API_KEY || API_KEY === "YOUR_API_KEY") {
                addChatMessage(userMessage, 'user');
                addChatMessage("Math Bot abhi available nahi hai kyunki API key set nahi hai.", 'bot');
                return;
            }

            addChatMessage(userMessage, 'user');
            chatInput.value = '';
            document.getElementById('send-chat-btn').disabled = true;
            document.getElementById('chat-loading-indicator').style.display = 'block';

            const gameContext = `...`; // Context remains same

            try {
                const payload = { contents: [{ role: "user", parts: [{ text: gameContext + "\n\nUser's question: " + userMessage }] }] };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const botResponse = result.candidates[0].content.parts[0].text;
                    addChatMessage(botResponse, 'bot');
                } else {
                    addChatMessage("Sorry, main abhi aapke sawaal ka jawab nahi de pa raha hoon. Kuch gadbad ho gayi.", 'bot');
                }
            } catch (error) {
                console.error('Chatbot API error:', error);
                addChatMessage("Network error ho gaya ya API call mein problem hai. Please try again.", 'bot');
            } finally {
                document.getElementById('send-chat-btn').disabled = false;
                document.getElementById('chat-loading-indicator').style.display = 'none';
            }
        }

        function toggleSetupVisibility() {
            const gameModeSelect = document.getElementById('game-mode');
            const player2BranchContainer = document.getElementById('player2-branch-selection-container');
            const player2BranchSelect = document.getElementById('branch-player2');
            const player2BranchDisplay = document.getElementById('branch-effect-display-player2');
            const aiDifficultyContainer = document.getElementById('ai-difficulty-select');

            if (gameModeSelect.value === 'vs_ai') {
                player2BranchContainer.style.display = 'none';
                player2BranchDisplay.style.display = 'none';
                aiDifficultyContainer.style.display = 'flex';
            } else {
                player2BranchContainer.style.display = 'flex';
                aiDifficultyContainer.style.display = 'none';
                if (player2BranchSelect.value) {
                    player2BranchDisplay.style.display = 'block';
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            displayBranchEffects('player1');
            displayBranchEffects('player2');
            updateStatus();
            updateDeckDiscardCounts();
            document.getElementById('game-ui').style.display = 'none';

            document.getElementById('game-mode').addEventListener('change', toggleSetupVisibility);
            toggleSetupVisibility();

            document.getElementById('chat-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
            
            const player1Slider = document.getElementById('player1-angle-slider');
            const player1AngleValue = document.getElementById('player1-angle-value');
            player1Slider.addEventListener('input', (event) => {
                const angle = event.target.value;
                player1AngleValue.textContent = angle;
                players.player1.angle = parseInt(angle, 10);
            });

            const player2Slider = document.getElementById('player2-angle-slider');
            const player2AngleValue = document.getElementById('player2-angle-value');
            player2Slider.addEventListener('input', (event) => {
                const angle = event.target.value;
                player2AngleValue.textContent = angle;
                players.player2.angle = parseInt(angle, 10);
            });
        });
    </script>

    <!-- Socket.IO Client -->
    <script src="/socket.io/socket.io.js"></script>

    <script>
        // Multiplayer functionality
        let socket;
        let isMultiplayer = false;
        let playerRole = null; // 'player1' or 'player2'
        let gameId = null;
        let opponentName = '';

        // Initialize multiplayer connection
        function initMultiplayer() {
            socket = io();
            isMultiplayer = true;

            // Connection events
            socket.on('connect', () => {
                console.log('Connected to server');
                document.getElementById('connection-status').textContent = 'Connected';
                document.getElementById('connection-status').className = 'text-green-600';
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                document.getElementById('connection-status').textContent = 'Disconnected';
                document.getElementById('connection-status').className = 'text-red-600';
            });

            // Game events
            socket.on('waiting-for-opponent', () => {
                showMessage('Waiting for opponent...', 'info');
            });

            socket.on('game-start', (data) => {
                gameId = data.gameId;
                showMessage(`Game started! Playing against ${getOpponentName(data.players)}`, 'success');
                // Initialize game with server state
                updateGameFromServer(data.gameState);
            });

            socket.on('player-role', (data) => {
                playerRole = data.role;
                opponentName = data.opponent;
                updatePlayerLabels();
            });

            socket.on('game-update', (data) => {
                updateGameFromServer(data.gameState);
                showMessage(`Opponent played: ${data.move.description || 'a card'}`, 'info');
            });

            socket.on('chat-message', (data) => {
                addChatMessage(data.player, data.message, data.timestamp);
            });

            socket.on('opponent-disconnected', () => {
                showMessage('Opponent disconnected', 'warning');
            });

            socket.on('game-end', (data) => {
                const winnerText = data.winner === playerRole ? 'You Won!' : 'You Lost!';
                showMessage(winnerText, data.winner === playerRole ? 'success' : 'error');
            });
        }

        // Join multiplayer queue
        function joinMultiplayerQueue() {
            if (!socket) initMultiplayer();

            const playerName = document.getElementById('player-name-input').value || 'Anonymous';
            socket.emit('join-queue', { name: playerName });

            document.getElementById('multiplayer-lobby').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
        }

        // Send move to server
        function sendMoveToServer(moveData) {
            if (socket && isMultiplayer) {
                socket.emit('make-move', moveData);
            }
        }

        // Send chat message
        function sendMultiplayerChat() {
            const input = document.getElementById('multiplayer-chat-input');
            const message = input.value.trim();
            if (message && socket) {
                socket.emit('chat-message', { message: message });
                input.value = '';
            }
        }

        // Update game state from server
        function updateGameFromServer(serverGameState) {
            // Sync local game state with server
            players.player1 = serverGameState.player1;
            players.player2 = serverGameState.player2;
            currentTurn = serverGameState.currentTurn;
            turnCount = serverGameState.turnCount;

            // Update UI
            updateDisplay();
            updateTurnIndicator();
        }

        // Helper functions
        function getOpponentName(playersData) {
            return playerRole === 'player1' ? playersData.player2.name : playersData.player1.name;
        }

        function updatePlayerLabels() {
            if (playerRole === 'player1') {
                document.getElementById('player1-label').textContent = 'You';
                document.getElementById('player2-label').textContent = opponentName;
            } else {
                document.getElementById('player1-label').textContent = opponentName;
                document.getElementById('player2-label').textContent = 'You';
            }
        }

        function addChatMessage(player, message, timestamp) {
            const chatContainer = document.getElementById('multiplayer-chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message p-2 mb-2 rounded';

            const time = new Date(timestamp).toLocaleTimeString();
            const playerName = player === playerRole ? 'You' : opponentName;

            messageDiv.innerHTML = `
                <div class="font-bold text-sm">${playerName} <span class="text-gray-500 text-xs">${time}</span></div>
                <div>${message}</div>
            `;

            if (player === playerRole) {
                messageDiv.classList.add('bg-blue-100');
            } else {
                messageDiv.classList.add('bg-gray-100');
            }

            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function showMessage(text, type) {
            // Show in-game messages
            const messageDiv = document.getElementById('game-messages');
            messageDiv.textContent = text;
            messageDiv.className = `message ${type}`;

            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.className = 'message';
            }, 3000);
        }
    </script>

</body>
</html>
